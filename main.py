#!/usr/bin/env python
import asyncio
import json
import logging
import os
import re
import sqlite3
import time
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from decimal import Decimal
import aiosqlite
import requests
from web3 import Web3
import urllib.parse
import threading
import sys
try:
    # Â∞ùËØïÊóßÁâàÊú¨ÂØºÂÖ•
    from web3.middleware import geth_poa_middleware
except ImportError:
    try:
        # Â∞ùËØïÊñ∞ÁâàÊú¨ÂØºÂÖ•
        from web3.middleware.geth_poa import geth_poa_middleware
    except ImportError:
        # Â¶ÇÊûúÈÉΩÂØºÂÖ•Â§±Ë¥•ÔºåÂàõÂª∫‰∏Ä‰∏™Á©∫ÁöÑ‰∏≠Èó¥‰ª∂ÂáΩÊï∞
        def geth_poa_middleware(w3):
            return w3
from eth_account import Account
from dotenv import load_dotenv
from colorama import init, Fore, Back, Style

# ÂàùÂßãÂåñcolorama
init(autoreset=True)

# Âä†ËΩΩÁéØÂ¢ÉÂèòÈáè
load_dotenv()

# ÈÖçÁΩÆÂ∏∏Èáè
TARGET_ADDRESS = os.getenv("TARGET_ADDRESS", "0x6b219df8c31c6b39a1a9b88446e0199be8f63cf1")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
COINGECKO_API_KEY = os.getenv("COINGECKO_API_KEY")

# È¢úËâ≤ËæìÂá∫ÂáΩÊï∞
def print_success(msg): 
    print(f"{Fore.GREEN}‚úÖ {msg}{Style.RESET_ALL}")

def translate_error_message(error_msg: str) -> str:
    """Â∞ÜÂ∏∏ËßÅÁöÑËã±ÊñáÈîôËØØ‰ø°ÊÅØÁøªËØë‰∏∫‰∏≠Êñá"""
    translations = {
        "insufficient funds": "‰ΩôÈ¢ù‰∏çË∂≥",
        "gas required exceeds allowance": "gasË¥πÁî®Ë∂ÖÂá∫ÈôêÂà∂",
        "transaction underpriced": "‰∫§Êòìgas‰ª∑Ê†ºËøá‰Ωé",
        "nonce too low": "nonceÂÄºËøá‰Ωé",
        "nonce too high": "nonceÂÄºËøáÈ´ò",
        "intrinsic gas too low": "ÂÜÖÂú®gasËøá‰Ωé",
        "exceeds block gas limit": "Ë∂ÖÂá∫Âå∫ÂùógasÈôêÂà∂",
        "replacement transaction underpriced": "ÊõøÊç¢‰∫§Êòìgas‰ª∑Ê†ºËøá‰Ωé",
        "already known": "‰∫§ÊòìÂ∑≤Áü•",
        "could not replace transaction": "Êó†Ê≥ïÊõøÊç¢‰∫§Êòì"
    }
    
    error_lower = error_msg.lower()
    for eng, chn in translations.items():
        if eng in error_lower:
            return f"{chn} ({error_msg})"
    
    return error_msg

def print_error(msg): 
    print(f"{Fore.RED}‚ùå {msg}{Style.RESET_ALL}")

def print_warning(msg): 
    print(f"{Fore.YELLOW}‚ö†Ô∏è  {msg}{Style.RESET_ALL}")

def print_info(msg): 
    print(f"{Fore.CYAN}‚ÑπÔ∏è  {msg}{Style.RESET_ALL}")

def print_progress(msg): 
    print(f"{Fore.BLUE}üîÑ {msg}{Style.RESET_ALL}")

def print_transfer(msg): 
    print(f"{Fore.MAGENTA}üí∏ {msg}{Style.RESET_ALL}")

def print_chain(msg): 
    print(f"{Fore.WHITE}{Back.BLUE} üîó {msg} {Style.RESET_ALL}")

def print_rpc(msg):
    print(f"{Fore.YELLOW}üåê {msg}{Style.RESET_ALL}")

def print_balance(msg):
    print(f"{Fore.GREEN}üí∞ {msg}{Style.RESET_ALL}")

def print_gas(msg):
    print(f"{Fore.CYAN}‚õΩ {msg}{Style.RESET_ALL}")

class ChainConfig:
    """ÈìæÈÖçÁΩÆÁ±ª"""
    
    # ÊîØÊåÅÁöÑÈìæÈÖçÁΩÆ - ÂåÖÂê´ÊâÄÊúâAlchemyÊîØÊåÅÁöÑEVMÈìæ
    SUPPORTED_CHAINS = {
        # ‰∏ªË¶Å‰∏ªÁΩë
        "ETH_MAINNET": {
            "chain_id": 1,
            "name": "Ethereum Mainnet",
            "rpc_url": "https://eth-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://etherscan.io"
        },
        "POLYGON_MAINNET": {
            "chain_id": 137,
            "name": "Polygon PoS",
            "rpc_url": "https://polygon-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "MATIC",
            "explorer": "https://polygonscan.com"
        },
        "ARBITRUM_ONE": {
            "chain_id": 42161,
            "name": "Arbitrum One",
            "rpc_url": "https://arb-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://arbiscan.io"
        },
        "OPTIMISM_MAINNET": {
            "chain_id": 10,
            "name": "OP Mainnet",
            "rpc_url": "https://opt-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://optimistic.etherscan.io"
        },
        "BASE_MAINNET": {
            "chain_id": 8453,
            "name": "Base",
            "rpc_url": "https://base-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://basescan.org"
        },
        "ARBITRUM_NOVA": {
            "chain_id": 42170,
            "name": "Arbitrum Nova",
            "rpc_url": "https://arbnova-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://nova.arbiscan.io"
        },
        "ZKSYNC_ERA": {
            "chain_id": 324,
            "name": "ZKsync Era",
            "rpc_url": "https://zksync-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://explorer.zksync.io"
        },
        "POLYGON_ZKEVM": {
            "chain_id": 1101,
            "name": "Polygon zkEVM",
            "rpc_url": "https://polygonzkevm-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://zkevm.polygonscan.com"
        },
        "AVALANCHE_C": {
            "chain_id": 43114,
            "name": "Avalanche C-Chain",
            "rpc_url": "https://avax-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "AVAX",
            "explorer": "https://snowtrace.io"
        },
        "BSC_MAINNET": {
            "chain_id": 56,
            "name": "BNB Smart Chain",
            "rpc_url": "https://bnb-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "BNB",
            "explorer": "https://bscscan.com"
        },
        "FANTOM_OPERA": {
            "chain_id": 250,
            "name": "Fantom Opera",
            "rpc_url": "https://fantom-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "FTM",
            "explorer": "https://ftmscan.com"
        },
        "BLAST": {
            "chain_id": 81457,
            "name": "Blast",
            "rpc_url": "https://blast-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://blastscan.io"
        },
        "LINEA": {
            "chain_id": 59144,
            "name": "Linea",
            "rpc_url": "https://linea-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://lineascan.build"
        },
        "MANTLE": {
            "chain_id": 5000,
            "name": "Mantle",
            "rpc_url": "https://mantle-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "MNT",
            "explorer": "https://mantlescan.org"
        },
        "GNOSIS": {
            "chain_id": 100,
            "name": "Gnosis",
            "rpc_url": "https://gnosis-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "xDAI",
            "explorer": "https://gnosisscan.io"
        },
        "CELO": {
            "chain_id": 42220,
            "name": "Celo",
            "rpc_url": "https://celo-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "CELO",
            "explorer": "https://celoscan.io"
        },
        "SCROLL": {
            "chain_id": 534352,
            "name": "Scroll",
            "rpc_url": "https://scroll-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://scrollscan.com"
        },
        
        # Êñ∞Â¢ûÈìæ
        "WORLD_CHAIN": {
            "chain_id": 480,
            "name": "World Chain",
            "rpc_url": "https://worldchain-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://worldscan.org"
        },
        "SHAPE": {
            "chain_id": 360,
            "name": "Shape",
            "rpc_url": "https://shape-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://shapescan.xyz"
        },
        "BERACHAIN": {
            "chain_id": 80084,
            "name": "Berachain",
            "rpc_url": "https://berachain-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "BERA",
            "explorer": "https://beratrail.io"
        },
        "UNICHAIN": {
            "chain_id": 1301,
            "name": "Unichain",
            "rpc_url": "https://unichain-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://uniscan.xyz"
        },
        "ZORA": {
            "chain_id": 7777777,
            "name": "Zora",
            "rpc_url": "https://zora-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://explorer.zora.energy"
        },
        "ASTAR": {
            "chain_id": 592,
            "name": "Astar",
            "rpc_url": "https://astar-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ASTR",
            "explorer": "https://astar.subscan.io"
        },
        "ZETACHAIN": {
            "chain_id": 7000,
            "name": "ZetaChain",
            "rpc_url": "https://zetachain-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ZETA",
            "explorer": "https://zetachain.blockscout.com"
        },
        "RONIN": {
            "chain_id": 2020,
            "name": "Ronin",
            "rpc_url": "https://ronin-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "RON",
            "explorer": "https://app.roninchain.com"
        },
        "SETTLUS": {
            "chain_id": 5372,
            "name": "Settlus",
            "rpc_url": "https://settlus-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "SETL",
            "explorer": "https://explorer.settlus.org"
        },
        "ROOTSTOCK": {
            "chain_id": 30,
            "name": "Rootstock",
            "rpc_url": "https://rootstock-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "RBTC",
            "explorer": "https://explorer.rsk.co"
        },
        "STORY": {
            "chain_id": 1513,
            "name": "Story",
            "rpc_url": "https://story-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "IP",
            "explorer": "https://testnet.storyscan.xyz"
        },
        "HUMANITY": {
            "chain_id": 1890,
            "name": "Humanity",
            "rpc_url": "https://humanity-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://explorer.humanity.org"
        },
        "HYPERLIQUID": {
            "chain_id": 998,
            "name": "Hyperliquid",
            "rpc_url": "https://hyperliquid-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://app.hyperliquid.xyz"
        },
        "GALACTICA": {
            "chain_id": 9302,
            "name": "Galactica",
            "rpc_url": "https://galactica-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "GNET",
            "explorer": "https://explorer.galactica.com"
        },
        "LENS": {
            "chain_id": 37111,
            "name": "Lens",
            "rpc_url": "https://lens-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "GRASS",
            "explorer": "https://block-explorer.lens.dev"
        },
        "FRAX": {
            "chain_id": 252,
            "name": "Frax",
            "rpc_url": "https://frax-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "frxETH",
            "explorer": "https://fraxscan.com"
        },
        "INK": {
            "chain_id": 57073,
            "name": "Ink",
            "rpc_url": "https://ink-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://explorer.inkonchain.com"
        },
        "BOTANIX": {
            "chain_id": 3636,
            "name": "Botanix",
            "rpc_url": "https://botanix-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "BTC",
            "explorer": "https://blockscout.botanixlabs.dev"
        },
        "BOBA": {
            "chain_id": 288,
            "name": "Boba",
            "rpc_url": "https://boba-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://bobascan.com"
        },
        "SUPERSEED": {
            "chain_id": 5330,
            "name": "Superseed",
            "rpc_url": "https://superseed-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://explorer.superseed.xyz"
        },
        "FLOW_EVM": {
            "chain_id": 747,
            "name": "Flow EVM",
            "rpc_url": "https://flow-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "FLOW",
            "explorer": "https://evm.flowscan.io"
        },
        "DEGEN": {
            "chain_id": 666666666,
            "name": "Degen",
            "rpc_url": "https://degen-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "DEGEN",
            "explorer": "https://explorer.degen.tips"
        },
        "APECHAIN": {
            "chain_id": 33139,
            "name": "ApeChain",
            "rpc_url": "https://apechain-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "APE",
            "explorer": "https://apechain.calderaexplorer.xyz"
        },
        "ANIME": {
            "chain_id": 11501,
            "name": "Anime",
            "rpc_url": "https://anime-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ANIME",
            "explorer": "https://animechain.ai"
        },
        "METIS": {
            "chain_id": 1088,
            "name": "Metis",
            "rpc_url": "https://metis-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "METIS",
            "explorer": "https://explorer.metis.io"
        },
        "SONIC": {
            "chain_id": 146,
            "name": "Sonic",
            "rpc_url": "https://sonic-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "S",
            "explorer": "https://explorer.soniclabs.com"
        },
        "SEI": {
            "chain_id": 1329,
            "name": "Sei",
            "rpc_url": "https://sei-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "SEI",
            "explorer": "https://seitrace.com"
        },
        "OPBNB": {
            "chain_id": 204,
            "name": "opBNB",
            "rpc_url": "https://opbnb-mainnet-rpc.bnbchain.org",
            "native_token": "BNB",
            "explorer": "https://opbnbscan.com"
        },
        "ABSTRACT": {
            "chain_id": 11124,
            "name": "Abstract",
            "rpc_url": "https://abstract-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://explorer.abstract.money"
        },
        "SONEIUM": {
            "chain_id": 1946,
            "name": "Soneium",
            "rpc_url": "https://soneium-mainnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://explorer.soneium.org"
        },
        
        # ÊµãËØïÁΩë
        "ETH_SEPOLIA": {
            "chain_id": 11155111,
            "name": "Ethereum Sepolia",
            "rpc_url": "https://eth-sepolia.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://sepolia.etherscan.io"
        },
        "POLYGON_AMOY": {
            "chain_id": 80002,
            "name": "Polygon Amoy",
            "rpc_url": "https://polygon-amoy.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "MATIC",
            "explorer": "https://amoy.polygonscan.com"
        },
        "ARBITRUM_SEPOLIA": {
            "chain_id": 421614,
            "name": "Arbitrum Sepolia",
            "rpc_url": "https://arb-sepolia.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://sepolia.arbiscan.io"
        },
        "OPTIMISM_SEPOLIA": {
            "chain_id": 11155420,
            "name": "Optimism Sepolia",
            "rpc_url": "https://opt-sepolia.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://sepolia-optimism.etherscan.io"
        },
        "BASE_SEPOLIA": {
            "chain_id": 84532,
            "name": "Base Sepolia",
            "rpc_url": "https://base-sepolia.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://sepolia.basescan.org"
        },
        "TEA_SEPOLIA": {
            "chain_id": 10218,
            "name": "Tea Sepolia",
            "rpc_url": "https://tea-sepolia.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "TEA",
            "explorer": "https://testnet.teascan.org"
        },
        "GENSYN_TESTNET": {
            "chain_id": 42069,
            "name": "Gensyn Testnet",
            "rpc_url": "https://gensyn-testnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "GEN",
            "explorer": "https://explorer.gensyn.ai"
        },
        "RISE_TESTNET": {
            "chain_id": 1821,
            "name": "Rise Testnet",
            "rpc_url": "https://rise-testnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://testnet.risescan.co"
        },
        "MONAD_TESTNET": {
            "chain_id": 41454,
            "name": "Monad Testnet",
            "rpc_url": "https://monad-testnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "MON",
            "explorer": "https://testnet.monad.xyz"
        },
        "XMTP_SEPOLIA": {
            "chain_id": 2692,
            "name": "XMTP Sepolia",
            "rpc_url": "https://xmtp-testnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "ETH",
            "explorer": "https://explorer.testnet.xmtp.network"
        },
        "CROSSFI_TESTNET": {
            "chain_id": 4157,
            "name": "CrossFi Testnet",
            "rpc_url": "https://crossfi-testnet.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "XFI",
            "explorer": "https://test.xfiscan.com"
        },
        "LUMIA_PRISM": {
            "chain_id": 1952959480,
            "name": "Lumia Prism",
            "rpc_url": "https://lumia-prism.g.alchemy.com/v2/PLACEHOLDER_API_KEY",
            "native_token": "LUMIA",
            "explorer": "https://explorer.lumia.org"
        }
    }

class DatabaseManager:
    """Êï∞ÊçÆÂ∫ìÁÆ°ÁêÜÁ±ª"""
    
    def __init__(self, db_path: str = "monitoring.db"):
        self.db_path = db_path
        self._lock = asyncio.Lock()  # Ê∑ªÂä†ÂºÇÊ≠•ÈîÅÈò≤Ê≠¢Âπ∂ÂèëËÆøÈóÆ
    
    async def init_database(self):
        """ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì"""
        async with aiosqlite.connect(self.db_path) as db:
            # ÂàõÂª∫Â±èËîΩÈìæË°®
            await db.execute("""
                CREATE TABLE IF NOT EXISTS blocked_chains (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    address TEXT NOT NULL,
                    chain_name TEXT NOT NULL,
                    chain_id INTEGER NOT NULL,
                    blocked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    reason TEXT DEFAULT 'No transaction history',
                    UNIQUE(address, chain_id)
                )
            """)
            
            # ÂàõÂª∫ËΩ¨Ë¥¶ËÆ∞ÂΩïË°®
            await db.execute("""
                CREATE TABLE IF NOT EXISTS transfers (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    address TEXT NOT NULL,
                    chain_name TEXT NOT NULL,
                    chain_id INTEGER NOT NULL,
                    amount TEXT NOT NULL,
                    recipient TEXT NOT NULL,
                    tx_hash TEXT,
                    gas_used TEXT,
                    gas_price TEXT,
                    status TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    error_message TEXT
                )
            """)
            
            # ÂàõÂª∫Êó•ÂøóË°®
            await db.execute("""
                CREATE TABLE IF NOT EXISTS logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    level TEXT NOT NULL,
                    message TEXT NOT NULL,
                    address TEXT,
                    chain_name TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # ÂàõÂª∫ÈÖçÁΩÆË°®
            await db.execute("""
                CREATE TABLE IF NOT EXISTS config (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            await db.commit()
    
    async def is_chain_blocked(self, address: str, chain_id: int) -> bool:
        """Ê£ÄÊü•ÈìæÊòØÂê¶Ë¢´Â±èËîΩ"""
        async with self._lock:
            try:
                async with aiosqlite.connect(self.db_path) as db:
                    cursor = await db.execute(
                        "SELECT 1 FROM blocked_chains WHERE address = ? AND chain_id = ?",
                        (address, chain_id)
                    )
                    result = await cursor.fetchone()
                    return result is not None
            except Exception as e:
                logging.error(f"Ê£ÄÊü•Â±èËîΩÈìæÁä∂ÊÄÅÂ§±Ë¥•: {e}")
                return False  # ÂÆâÂÖ®ÈªòËÆ§ÂÄºÔºöÂÅáËÆæÊú™Â±èËîΩ
    
    async def block_chain(self, address: str, chain_name: str, chain_id: int, reason: str = "No transaction history"):
        """Â±èËîΩÈìæ"""
        async with self._lock:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    """INSERT OR IGNORE INTO blocked_chains 
                       (address, chain_name, chain_id, reason) VALUES (?, ?, ?, ?)""",
                    (address, chain_name, chain_id, reason)
                )
                await db.commit()
    
    async def log_transfer(self, address: str, chain_name: str, chain_id: int, 
                          amount: str, recipient: str, tx_hash: str = None, 
                          gas_used: str = None, gas_price: str = None, 
                          status: str = "pending", error_message: str = None):
        """ËÆ∞ÂΩïËΩ¨Ë¥¶"""
        async with self._lock:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    """INSERT INTO transfers 
                       (address, chain_name, chain_id, amount, recipient, tx_hash, 
                        gas_used, gas_price, status, error_message) 
                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                    (address, chain_name, chain_id, amount, recipient, tx_hash, 
                     gas_used, gas_price, status, error_message)
                )
                await db.commit()
    
    async def log_message(self, level: str, message: str, address: str = None, chain_name: str = None):
        """ËÆ∞ÂΩïÊó•ÂøóÊ∂àÊÅØ"""
        async with self._lock:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    "INSERT INTO logs (level, message, address, chain_name) VALUES (?, ?, ?, ?)",
                    (level, message, address, chain_name)
                )
                await db.commit()
    
    async def get_blocked_chains(self, address: str = None) -> List[Dict]:
        """Ëé∑ÂèñÂ±èËîΩÈìæÂàóË°®"""
        async with aiosqlite.connect(self.db_path) as db:
            if address:
                cursor = await db.execute(
                    "SELECT * FROM blocked_chains WHERE address = ? ORDER BY blocked_at DESC",
                    (address,)
                )
            else:
                cursor = await db.execute(
                    "SELECT * FROM blocked_chains ORDER BY blocked_at DESC"
                )
            
            rows = await cursor.fetchall()
            columns = [description[0] for description in cursor.description]
            return [dict(zip(columns, row)) for row in rows]
    
    async def get_transfer_history(self, address: str = None, limit: int = 100) -> List[Dict]:
        """Ëé∑ÂèñËΩ¨Ë¥¶ÂéÜÂè≤"""
        async with aiosqlite.connect(self.db_path) as db:
            if address:
                cursor = await db.execute(
                    "SELECT * FROM transfers WHERE address = ? ORDER BY created_at DESC LIMIT ?",
                    (address, limit)
                )
            else:
                cursor = await db.execute(
                    "SELECT * FROM transfers ORDER BY created_at DESC LIMIT ?",
                    (limit,)
                )
            
            rows = await cursor.fetchall()
            columns = [description[0] for description in cursor.description]
            return [dict(zip(columns, row)) for row in rows]

class PriceChecker:
    """‰ª£Â∏Å‰ª∑Ê†ºÊü•ËØ¢Á±ª - ‰ºòÂåñÁâàÊú¨ÊîØÊåÅÈïøÊúüÁºìÂ≠òÂíåAPIÈôêÂà∂"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
        # ÈïøÊúüÁºìÂ≠òËÆæÁΩÆ - ÂàÜÂ±ÇÁºìÂ≠òÁ≠ñÁï•
        self.price_cache = {}  # ÂÜÖÂ≠òÁºìÂ≠ò
        self.cache_duration = 24 * 3600  # Ê≠£Â∏∏ÁºìÂ≠ò1Â§©Ôºà86400ÁßíÔºâ
        self.extended_cache_duration = 7 * 24 * 3600  # APIÂèóÈôêÊó∂‰ΩøÁî®7Â§©ÁºìÂ≠ò
        self.cache_file = "price_cache.json"  # ÊåÅ‰πÖÂåñÁºìÂ≠òÊñá‰ª∂
        
        # APIÈôêÂà∂ÁÆ°ÁêÜ
        self.api_calls_per_minute = 30  # ÊØèÂàÜÈíüÊúÄÂ§ö30Ê¨°
        self.api_calls_per_month = 10000  # ÊØèÊúàÊúÄÂ§ö10000Ê¨°
        self.minute_calls = []  # ËÆ∞ÂΩïÊØèÂàÜÈíüÁöÑË∞ÉÁî®
        self.monthly_calls = 0  # ÂΩìÊúàÊÄªË∞ÉÁî®Ê¨°Êï∞
        self.month_start = datetime.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        
        # Â∏∏ËßÅ‰ª£Â∏ÅÁöÑCoinGecko IDÊò†Â∞Ñ - Êâ©Â±ïÁâà
        self.token_id_map = {
            # ‰∏ªË¶Å‰ª£Â∏Å
            "USDT": "tether",
            "USDC": "usd-coin", 
            "DAI": "dai",
            "WETH": "weth",
            "ETH": "ethereum",
            "WBTC": "wrapped-bitcoin",
            "BTC": "bitcoin",
            "UNI": "uniswap",
            "LINK": "chainlink",
            "AAVE": "aave",
            "COMP": "compound-governance-token",
            "MKR": "maker",
            "SNX": "havven",
            "YFI": "yearn-finance",
            "SUSHI": "sushi",
            "1INCH": "1inch",
            "CRV": "curve-dao-token",
            "BAL": "balancer",
            "MATIC": "matic-network",
            "AVAX": "avalanche-2",
            "FTM": "fantom",
            "BNB": "binancecoin",
            "ADA": "cardano",
            "SOL": "solana",
            "DOT": "polkadot",
            "ATOM": "cosmos",
            "NEAR": "near",
            "ALGO": "algorand",
            "XTZ": "tezos",
            "EGLD": "elrond-erd-2",
            "LUNA": "terra-luna-2",
        }
        
        # Âä†ËΩΩÊåÅ‰πÖÂåñÁºìÂ≠ò
        self._load_cache()
        self._load_api_stats()
    
    def _load_cache(self):
        """Âä†ËΩΩÊåÅ‰πÖÂåñÁºìÂ≠ò"""
        try:
            if os.path.exists(self.cache_file):
                with open(self.cache_file, 'r') as f:
                    cache_data = json.load(f)
                    self.price_cache = cache_data.get('prices', {})
                    print_info(f"üì¶ Âä†ËΩΩ‰ª∑Ê†ºÁºìÂ≠ò: {len(self.price_cache)} Êù°ËÆ∞ÂΩï")
        except Exception as e:
            logging.debug(f"Âä†ËΩΩ‰ª∑Ê†ºÁºìÂ≠òÂ§±Ë¥•: {e}")
            self.price_cache = {}
    
    def _save_cache(self):
        """‰øùÂ≠òÊåÅ‰πÖÂåñÁºìÂ≠ò"""
        try:
            cache_data = {
                'prices': self.price_cache,
                'last_updated': time.time()
            }
            with open(self.cache_file, 'w') as f:
                json.dump(cache_data, f)
        except Exception as e:
            logging.debug(f"‰øùÂ≠ò‰ª∑Ê†ºÁºìÂ≠òÂ§±Ë¥•: {e}")
    
    def _load_api_stats(self):
        """Âä†ËΩΩAPIË∞ÉÁî®ÁªüËÆ°"""
        try:
            stats_file = "api_stats.json"
            if os.path.exists(stats_file):
                with open(stats_file, 'r') as f:
                    stats = json.load(f)
                    self.monthly_calls = stats.get('monthly_calls', 0)
                    saved_month = stats.get('month_start')
                    if saved_month:
                        saved_month_dt = datetime.fromisoformat(saved_month)
                        current_month = datetime.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
                        if saved_month_dt.month != current_month.month or saved_month_dt.year != current_month.year:
                            # Êñ∞Êúà‰ªΩÔºåÈáçÁΩÆËÆ°Êï∞
                            self.monthly_calls = 0
                            self.month_start = current_month
                        else:
                            self.month_start = saved_month_dt
                    print_info(f"üìä Êú¨ÊúàAPIË∞ÉÁî®: {self.monthly_calls}/10,000")
        except Exception as e:
            logging.debug(f"Âä†ËΩΩAPIÁªüËÆ°Â§±Ë¥•: {e}")
    
    def _save_api_stats(self):
        """‰øùÂ≠òAPIË∞ÉÁî®ÁªüËÆ°"""
        try:
            stats = {
                'monthly_calls': self.monthly_calls,
                'month_start': self.month_start.isoformat()
            }
            with open("api_stats.json", 'w') as f:
                json.dump(stats, f)
        except Exception as e:
            logging.debug(f"‰øùÂ≠òAPIÁªüËÆ°Â§±Ë¥•: {e}")
    
    def _can_make_api_call(self) -> bool:
        """Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ËøõË°åAPIË∞ÉÁî®"""
        current_time = time.time()
        
        # Ê∏ÖÁêÜ1ÂàÜÈíüÂâçÁöÑË∞ÉÁî®ËÆ∞ÂΩï
        self.minute_calls = [call_time for call_time in self.minute_calls if current_time - call_time <= 60]
        
        # Ê£ÄÊü•ÂàÜÈíüÈôêÂà∂
        if len(self.minute_calls) >= self.api_calls_per_minute:
            print_warning(f"‚ö†Ô∏è APIÂàÜÈíüÈôêÂà∂: {len(self.minute_calls)}/30ÔºåÊöÇÂÅúË∞ÉÁî®")
            return False
        
        # Ê£ÄÊü•ÊúàÂ∫¶ÈôêÂà∂
        if self.monthly_calls >= self.api_calls_per_month:
            print_error(f"‚ùå APIÊúàÂ∫¶È¢ùÂ∫¶Â∑≤Áî®ÂÆå: {self.monthly_calls}/10,000")
            return False
        
        return True
    
    def _record_api_call(self):
        """ËÆ∞ÂΩïAPIË∞ÉÁî®"""
        current_time = time.time()
        self.minute_calls.append(current_time)
        self.monthly_calls += 1
        self._save_api_stats()
        
        print_info(f"üîå APIË∞ÉÁî®: ÂàÜÈíü {len(self.minute_calls)}/30, ÊúàÂ∫¶ {self.monthly_calls}/10,000")
    
    async def get_token_price_usd(self, token_symbol: str, contract_address: str = None) -> Optional[float]:
        """Ëé∑Âèñ‰ª£Â∏ÅÁöÑUSD‰ª∑Ê†º - ‰ºòÂåñÁâàÊú¨"""
        try:
            # ÁîüÊàêÁºìÂ≠òÈîÆ
            cache_key = f"{token_symbol.upper()}_{contract_address if contract_address else 'None'}"
            current_time = time.time()
            
            # Ê£ÄÊü•ÂàÜÂ±ÇÁºìÂ≠ò
            if cache_key in self.price_cache:
                cached_data = self.price_cache[cache_key]
                if isinstance(cached_data, dict):
                    cached_price = cached_data.get('price')
                    cached_time = cached_data.get('time', 0)
                else:
                    # ÂÖºÂÆπÊóßÊ†ºÂºè
                    cached_price, cached_time = cached_data if isinstance(cached_data, tuple) else (cached_data, 0)
                
                cache_age = current_time - cached_time
                # Ê≠£Â∏∏ÊÉÖÂÜµ‰∏ã‰ΩøÁî®1Â§©ÁºìÂ≠òÔºåAPIÂèóÈôêÊó∂‰ΩøÁî®7Â§©ÁºìÂ≠ò
                active_cache_duration = self.extended_cache_duration if not self._can_make_api_call() else self.cache_duration
                
                if cache_age < active_cache_duration:
                    cache_status = "Êâ©Â±ï" if cache_age > self.cache_duration else "Ê≠£Â∏∏"
                    print_info(f"üí∞ ‰ΩøÁî®{cache_status}ÁºìÂ≠ò‰ª∑Ê†º: {token_symbol} = ${cached_price:.6f} (ÁºìÂ≠òÂâ©‰Ωô: {(active_cache_duration - cache_age)/3600:.1f}Â∞èÊó∂)")
                    return cached_price
            
            # Ê£ÄÊü•APIË∞ÉÁî®ÈôêÂà∂
            if not self._can_make_api_call():
                print_warning(f"‚ö†Ô∏è APIÈ¢ùÂ∫¶‰∏çË∂≥ÔºåËøîÂõûÁºìÂ≠ò‰ª∑Ê†ºÊàñÈªòËÆ§ÂÄº")
                # ËøîÂõûËøáÊúüÁºìÂ≠òÊàñNone
                if cache_key in self.price_cache:
                    cached_data = self.price_cache[cache_key]
                    if isinstance(cached_data, dict):
                        return cached_data.get('price')
                    else:
                        return cached_data[0] if isinstance(cached_data, tuple) else cached_data
                return None
            
            # Â∞ùËØïÈÄöËøáÁ¨¶Âè∑Êü•ËØ¢
            token_id = self.token_id_map.get(token_symbol.upper())
            price = None
            
            if token_id:
                price = await self._query_coingecko_by_id(token_id)
            
            # Â¶ÇÊûúÁ¨¶Âè∑Êü•ËØ¢Â§±Ë¥•‰∏îÊúâÂêàÁ∫¶Âú∞ÂùÄÔºåÂ∞ùËØïÈÄöËøáÂêàÁ∫¶Âú∞ÂùÄÊü•ËØ¢
            if price is None and contract_address:
                price = await self._query_coingecko_by_contract(contract_address)
            
            # Â¶ÇÊûúÈÉΩÂ§±Ë¥•ÔºåÂ∞ùËØïÊêúÁ¥¢ÔºàÊúÄÂêéÊâãÊÆµÔºâ
            if price is None:
                price = await self._search_coingecko_by_symbol(token_symbol)
            
            # ÁºìÂ≠òÁªìÊûú
            if price is not None:
                self.price_cache[cache_key] = {
                    'price': price,
                    'time': current_time,
                    'symbol': token_symbol.upper(),
                    'contract': contract_address
                }
                self._save_cache()
                print_success(f"üí∞ Ëé∑ÂèñÊñ∞‰ª∑Ê†º: {token_symbol} = ${price:.6f}")
                return price
            else:
                print_warning(f"‚ö†Ô∏è Êó†Ê≥ïËé∑Âèñ‰ª∑Ê†º: {token_symbol}")
                return None
            
        except Exception as e:
            logging.debug(f"Ëé∑Âèñ‰ª£Â∏Å‰ª∑Ê†ºÂ§±Ë¥• {token_symbol}: {e}")
            return None
    
    async def _query_coingecko_by_id(self, token_id: str) -> Optional[float]:
        """ÈÄöËøáCoinGecko IDÊü•ËØ¢‰ª∑Ê†º"""
        try:
            self._record_api_call()  # ËÆ∞ÂΩïAPIË∞ÉÁî®
            
            # ‰ΩøÁî®ÂÖçË¥πÂÖ¨ÂÖ±API URL
            url = f"https://api.coingecko.com/api/v3/simple/price?ids={token_id}&vs_currencies=usd"
            
            response = self.session.get(url, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if token_id in data and 'usd' in data[token_id]:
                price = float(data[token_id]['usd'])
                print_success(f"üîç APIÊü•ËØ¢ÊàêÂäü: {token_id} = ${price:.6f}")
                return price
            
            return None
            
        except Exception as e:
            logging.debug(f"CoinGecko IDÊü•ËØ¢Â§±Ë¥• {token_id}: {e}")
            print_error(f"APIÊü•ËØ¢Â§±Ë¥•: {token_id} - {e}")
            return None
    
    async def _query_coingecko_by_contract(self, contract_address: str) -> Optional[float]:
        """ÈÄöËøáÂêàÁ∫¶Âú∞ÂùÄÊü•ËØ¢‰ª∑Ê†º"""
        try:
            self._record_api_call()  # ËÆ∞ÂΩïAPIË∞ÉÁî®
            
            # ‰ΩøÁî®ÂÖçË¥πÂÖ¨ÂÖ±API URLÔºåÂ∞ùËØï‰ª•Â§™Âùä‰∏ªÁΩë
            url = f"https://api.coingecko.com/api/v3/simple/token_price/ethereum?contract_addresses={contract_address}&vs_currencies=usd"
            
            response = self.session.get(url, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            contract_lower = contract_address.lower()
            if contract_lower in data and 'usd' in data[contract_lower]:
                price = float(data[contract_lower]['usd'])
                print_success(f"üîç ÂêàÁ∫¶Êü•ËØ¢ÊàêÂäü: {contract_address[:8]}... = ${price:.6f}")
                return price
            
            return None
            
        except Exception as e:
            logging.debug(f"CoinGeckoÂêàÁ∫¶Êü•ËØ¢Â§±Ë¥• {contract_address}: {e}")
            print_error(f"ÂêàÁ∫¶Êü•ËØ¢Â§±Ë¥•: {contract_address[:8]}... - {e}")
            return None
    
    async def _search_coingecko_by_symbol(self, symbol: str) -> Optional[float]:
        """ÈÄöËøáÁ¨¶Âè∑ÊêúÁ¥¢‰ª∑Ê†ºÔºàË∞®ÊÖé‰ΩøÁî®Ôºâ"""
        try:
            # ÊêúÁ¥¢APIË∞ÉÁî®Ê∂àËÄóÈ¢ùÂ∫¶ÔºåË∞®ÊÖé‰ΩøÁî®
            if not self._can_make_api_call():
                return None
            self._record_api_call()  # ËÆ∞ÂΩïAPIË∞ÉÁî®
            
            url = f"https://api.coingecko.com/api/v3/search?query={urllib.parse.quote(symbol)}"
            response = self.session.get(url, timeout=10)
            response.raise_for_status()
            data = response.json()
            if 'coins' in data and len(data['coins']) > 0:
                first_coin = data['coins'][0]
                token_id = first_coin['id']
                print_info(f"üîç ÊêúÁ¥¢ÊâæÂà∞: {symbol} -> {token_id}")
                # Ê≥®ÊÑèÔºöËøôÈáå‰ºöÂÜçÊ¨°Ë∞ÉÁî®APIÔºå‰ΩÜ_query_coingecko_by_id‰ºöËá™Â∑±ËÆ∞ÂΩïAPIË∞ÉÁî®
                return await self._query_coingecko_by_id(token_id)
            
            return None
            
        except Exception as e:
            logging.debug(f"CoinGeckoÊêúÁ¥¢Â§±Ë¥• {symbol}: {e}")
            print_error(f"ÊêúÁ¥¢Â§±Ë¥•: {symbol} - {e}")
            return None
    
    def get_cache_stats(self) -> Dict:
        """Ëé∑ÂèñÁºìÂ≠òÁªüËÆ°‰ø°ÊÅØ"""
        current_time = time.time()
        total_cached = len(self.price_cache)
        valid_cached = 0
        expired_cached = 0
        
        for cache_data in self.price_cache.values():
            if isinstance(cache_data, dict):
                cached_time = cache_data.get('time', 0)
            else:
                cached_time = cache_data[1] if isinstance(cache_data, tuple) else 0
            
            if current_time - cached_time < self.cache_duration:
                valid_cached += 1
            else:
                expired_cached += 1
        
        return {
            'total_cached': total_cached,
            'valid_cached': valid_cached,
            'expired_cached': expired_cached,
            'monthly_calls': self.monthly_calls,
            'monthly_limit': self.api_calls_per_month,
            'minute_calls': len(self.minute_calls),
            'minute_limit': self.api_calls_per_minute
        }

class AlchemyAPILoadBalancer:
    """Alchemy API Êô∫ËÉΩË¥üËΩΩÂùáË°°Âô®"""
    
    def __init__(self, api_keys: List[str]):
        self.api_keys = api_keys
        self.api_instances = []
        self.current_api_index = 0
        self.request_count = 0
        
        # ‰∏∫ÊØè‰∏™APIÂØÜÈí•ÂàõÂª∫ÂÆû‰æã
        for i, api_key in enumerate(api_keys):
            api_instance = AlchemyAPI(api_key, f"API-{i+1}")
            self.api_instances.append(api_instance)
            print_success(f"üîß ÂàùÂßãÂåñAPIÂÆû‰æã {i+1}: {api_key[:12]}...")
        
        print_success(f"üöÄ Ë¥üËΩΩÂùáË°°Âô®ÂàùÂßãÂåñÂÆåÊàêÔºö{len(self.api_instances)} ‰∏™APIÂÆû‰æã")
        print_info(f"üìä ÊÄªÁõÆÊ†áÈÄüÂ∫¶Ôºö{len(self.api_instances) * 500} CU/s")
    
    def get_next_api(self) -> 'AlchemyAPI':
        """Êô∫ËÉΩËé∑Âèñ‰∏ã‰∏Ä‰∏™ÂèØÁî®ÁöÑAPIÂÆû‰æã"""
        # ËΩÆËØ¢Á≠ñÁï•ÔºöÂùáÂåÄÂàÜÈÖçËØ∑Ê±Ç
        api = self.api_instances[self.current_api_index]
        
        # Ê£ÄÊü•ÂΩìÂâçAPIÊòØÂê¶ÂèØÁî®
        if api.is_api_available():
            self.current_api_index = (self.current_api_index + 1) % len(self.api_instances)
            return api
        
        # Â¶ÇÊûúÂΩìÂâçAPI‰∏çÂèØÁî®ÔºåÂØªÊâæÂèØÁî®ÁöÑAPI
        for i in range(len(self.api_instances)):
            test_index = (self.current_api_index + i) % len(self.api_instances)
            test_api = self.api_instances[test_index]
            if test_api.is_api_available():
                self.current_api_index = (test_index + 1) % len(self.api_instances)
                return test_api
        
        # ÊâÄÊúâAPIÈÉΩ‰∏çÂèØÁî®ÔºåËøîÂõûÁ¨¨‰∏Ä‰∏™ÔºàËÆ©ÂÆÉÂ§ÑÁêÜÈôêÊµÅÔºâ
        print_warning("‚ö†Ô∏è ÊâÄÊúâAPIÈÉΩËææÂà∞ÈôêÂà∂Ôºå‰ΩøÁî®Á¨¨‰∏Ä‰∏™API")
        return self.api_instances[0]
    
    def get_usage_stats(self) -> Dict:
        """Ëé∑ÂèñÊâÄÊúâAPIÁöÑ‰ΩøÁî®ÁªüËÆ°"""
        total_stats = {
            "total_cu_rate": 0,
            "total_monthly_usage": 0,
            "total_monthly_limit": 0,
            "api_details": []
        }
        
        for i, api in enumerate(self.api_instances):
            stats = api.get_usage_stats()
            total_stats["total_cu_rate"] += stats["current_cu_rate"]
            total_stats["total_monthly_usage"] += stats["monthly_usage"]
            total_stats["total_monthly_limit"] += stats["monthly_limit"]
            
            api_detail = {
                "api_index": i + 1,
                "api_key_preview": api.api_key[:12] + "...",
                "current_cu_rate": stats["current_cu_rate"],
                "monthly_usage": stats["monthly_usage"],
                "monthly_limit": stats["monthly_limit"],
                "usage_percentage": stats["usage_percentage"],
                "available": api.is_api_available()
            }
            total_stats["api_details"].append(api_detail)
        
        total_stats["usage_percentage"] = (total_stats["total_monthly_usage"] / total_stats["total_monthly_limit"]) * 100 if total_stats["total_monthly_limit"] > 0 else 0
        return total_stats
    
    # ‰ª£ÁêÜÊñπÊ≥ïÔºåËá™Âä®ÈÄâÊã©ÊúÄ‰Ω≥API
    async def check_asset_transfers(self, address: str, chain_config: Dict) -> Tuple[bool, int]:
        api = self.get_next_api()
        return await api.check_asset_transfers(address, chain_config)
    
    async def get_balance(self, address: str, chain_config: Dict) -> float:
        api = self.get_next_api()
        return await api.get_balance(address, chain_config)
    
    async def get_all_token_balances(self, address: str, chain_config: Dict) -> Dict[str, Dict]:
        api = self.get_next_api()
        return await api.get_all_token_balances(address, chain_config)
    
    async def get_token_metadata(self, contract_address: str, chain_config: Dict) -> Dict:
        api = self.get_next_api()
        return await api.get_token_metadata(contract_address, chain_config)
    
    async def get_gas_price(self, chain_config: Dict) -> Dict:
        api = self.get_next_api()
        return await api.get_gas_price(chain_config)

class AlchemyAPI:
    """Alchemy API Â∞ÅË£ÖÁ±ª"""
    
    def __init__(self, api_key: str, instance_name: str = "API"):
        self.api_key = api_key
        self.instance_name = instance_name
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
        })
        
        # APIÈôêÈ¢ëÊéßÂà∂ - Êô∫ËÉΩÈÄüÁéáÊéßÂà∂ÔºåÂçï‰∏™APIÁõÆÊ†á480 CU/sÔºàÁïô10%‰ΩôÈáèÔºâ
        self.last_request_time = 0
        self.target_cu_per_second = 480  # Âçï‰∏™APIÁõÆÊ†á480 CU/sÔºåÁïô20 CU/s‰ΩôÈáè
        self.max_cu_per_second = 500     # ÊúÄÂ§ß‰∏çË∂ÖËøá500 CU/s
        self.cu_per_request = 1          # ÊØè‰∏™ËØ∑Ê±ÇÊ∂àËÄóÁöÑCUÊï∞ÔºåÂä®ÊÄÅË∞ÉÊï¥
        self.request_history = []        # ËØ∑Ê±ÇÂéÜÂè≤ËÆ∞ÂΩï
        self.current_cu_rate = 0         # ÂΩìÂâçCUÈÄüÁéá
        
        # ÊúàÂ∫¶È¢ùÂ∫¶ÁÆ°ÁêÜ
        self.monthly_cu_limit = 30_000_000  # ÊØèÊúà3000‰∏áCU
        self.current_month_usage = 0        # ÂΩìÊúàÂ∑≤‰ΩøÁî®CU
        self.month_start_time = None        # ÊúàÂàùÊó∂Èó¥
        self.daily_cu_budget = 0            # ÊØèÊó•CUÈ¢ÑÁÆó
        self.today_usage = 0                # ‰ªäÊó•Â∑≤‰ΩøÁî®CU
        
        # APIÂèØÁî®ÊÄßÊ£ÄÊü•
        self.last_failure_time = 0
        self.failure_count = 0
        self.cooldown_duration = 60  # Â§±Ë¥•ÂêéÁöÑÂÜ∑Âç¥Êó∂Èó¥ÔºàÁßíÔºâ
    
    def is_api_available(self) -> bool:
        """Ê£ÄÊü•APIÊòØÂê¶ÂèØÁî®"""
        current_time = time.time()
        
        # Ê£ÄÊü•CU‰ΩøÁî®ÁéáÊòØÂê¶Ë∂ÖÈôê
        if self.current_cu_rate >= self.max_cu_per_second:
            return False
        
        # Ê£ÄÊü•ÊúàÂ∫¶È¢ùÂ∫¶ÊòØÂê¶ËÄóÂ∞Ω
        if self.current_month_usage >= self.monthly_cu_limit * 0.95:  # 95%È¢ÑË≠¶
            return False
        
        # Ê£ÄÊü•ÊòØÂê¶Âú®Â§±Ë¥•ÂÜ∑Âç¥Êúü
        if self.failure_count > 3 and (current_time - self.last_failure_time) < self.cooldown_duration:
            return False
        
        return True
    
    def record_failure(self):
        """ËÆ∞ÂΩïAPIÂ§±Ë¥•"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        print_warning(f"‚ö†Ô∏è {self.instance_name} ËÆ∞ÂΩïÂ§±Ë¥• #{self.failure_count}")
    
    def record_success(self):
        """ËÆ∞ÂΩïAPIÊàêÂäüÔºåÈáçÁΩÆÂ§±Ë¥•ËÆ°Êï∞"""
        if self.failure_count > 0:
            print_success(f"‚úÖ {self.instance_name} ÊÅ¢Â§çÊ≠£Â∏∏")
        self.failure_count = 0
    
    async def _rate_limit(self, cu_cost: int = 1):
        """Êô∫ËÉΩAPIÈôêÈ¢ëÊéßÂà∂"""
        current_time = time.time()
        
        # Ê∏ÖÁêÜ1ÁßíÂâçÁöÑËØ∑Ê±ÇËÆ∞ÂΩï
        self.request_history = [
            (timestamp, cu) for timestamp, cu in self.request_history 
            if current_time - timestamp <= 1.0
        ]
        
        # ËÆ°ÁÆóÂΩìÂâçCUÈÄüÁéá
        current_cu_usage = sum(cu for _, cu in self.request_history)
        
        # Â¶ÇÊûúÂä†‰∏äÂΩìÂâçËØ∑Ê±Ç‰ºöË∂ÖËøáÁõÆÊ†áÈÄüÁéáÔºåÂàôÁ≠âÂæÖ
        if current_cu_usage + cu_cost > self.target_cu_per_second:
            # ËÆ°ÁÆóÈúÄË¶ÅÁ≠âÂæÖÁöÑÊó∂Èó¥
            oldest_timestamp = min(timestamp for timestamp, _ in self.request_history) if self.request_history else current_time
            wait_time = 1.0 - (current_time - oldest_timestamp) + 0.001  # ÂáèÂ∞ëÁ≠âÂæÖÊó∂Èó¥ÔºåÊèêÂçáÈÄüÂ∫¶
            if wait_time > 0:
                print_info(f"üö¶ {self.instance_name} ÈôêÈ¢ëÁ≠âÂæÖ {wait_time:.3f}s (ÂΩìÂâç: {current_cu_usage}/{self.target_cu_per_second} CU/s)")
                await asyncio.sleep(wait_time)
                current_time = time.time()
                # ÈáçÊñ∞Ê∏ÖÁêÜËØ∑Ê±ÇËÆ∞ÂΩï
                self.request_history = [
                    (timestamp, cu) for timestamp, cu in self.request_history 
                    if current_time - timestamp <= 1.0
                ]
        
        # ËÆ∞ÂΩïÂΩìÂâçËØ∑Ê±Ç
        self.request_history.append((current_time, cu_cost))
        self.last_request_time = current_time
        
        # Êõ¥Êñ∞ÂΩìÂâçÈÄüÁéá
        self.current_cu_rate = sum(cu for _, cu in self.request_history)
        
        # Êõ¥Êñ∞ÊúàÂ∫¶ÂíåÊó•Â∫¶‰ΩøÁî®ÁªüËÆ°
        self._update_usage_stats(cu_cost)
    
    def _update_usage_stats(self, cu_cost: int):
        """Êõ¥Êñ∞‰ΩøÁî®ÁªüËÆ°"""
        from datetime import datetime, timezone
        
        now = datetime.now(timezone.utc)
        
        # Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÈáçÁΩÆÊúàÂ∫¶ÁªüËÆ°ÔºàÊñ∞Êúà‰ªΩÂºÄÂßãÊó∂Ôºâ
        if self.month_start_time is None:
            # È¶ñÊ¨°ÂàùÂßãÂåñ
            self.month_start_time = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
            self.current_month_usage = 0
        elif now.month != self.month_start_time.month or now.year != self.month_start_time.year:
            # Êñ∞Êúà‰ªΩÊàñÊñ∞Âπ¥‰ªΩÔºåÈáçÁΩÆÁªüËÆ°
            self.month_start_time = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
            self.current_month_usage = 0
            print_info(f"üîÑ ÊúàÂ∫¶È¢ùÂ∫¶Â∑≤ÈáçÁΩÆ: {self.monthly_cu_limit:,} CU")
        
        # Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÈáçÁΩÆÊØèÊó•ÁªüËÆ°
        if hasattr(self, 'last_reset_day'):
            if now.day != self.last_reset_day:
                self.today_usage = 0
                self.last_reset_day = now.day
                print_info(f"üåÖ ÊØèÊó•ÁªüËÆ°Â∑≤ÈáçÁΩÆ")
        else:
            self.last_reset_day = now.day
        
        # Êõ¥Êñ∞‰ΩøÁî®Èáè
        self.current_month_usage += cu_cost
        self.today_usage += cu_cost
        
        # ËÆ°ÁÆóÂâ©‰ΩôÂ§©Êï∞ÂíåÊØèÊó•È¢ÑÁÆó
        days_in_month = (now.replace(month=now.month+1 if now.month < 12 else 1, 
                                   year=now.year if now.month < 12 else now.year+1, day=1) - 
                        self.month_start_time).days
        days_remaining = days_in_month - now.day + 1
        
        if days_remaining > 0:
            remaining_cu = self.monthly_cu_limit - self.current_month_usage
            self.daily_cu_budget = max(0, remaining_cu // days_remaining)
            
            # È¢ùÂ∫¶È¢ÑË≠¶
            usage_percentage = (self.current_month_usage / self.monthly_cu_limit) * 100
            if usage_percentage >= 90 and not hasattr(self, 'warned_90'):
                print_warning(f"‚ö†Ô∏è ÊúàÂ∫¶È¢ùÂ∫¶È¢ÑË≠¶: Â∑≤‰ΩøÁî® {usage_percentage:.1f}%")
                self.warned_90 = True
            elif usage_percentage >= 75 and not hasattr(self, 'warned_75'):
                print_warning(f"‚ö†Ô∏è ÊúàÂ∫¶È¢ùÂ∫¶ÊèêÈÜí: Â∑≤‰ΩøÁî® {usage_percentage:.1f}%")
                self.warned_75 = True
    
    def get_usage_stats(self) -> Dict:
        """Ëé∑Âèñ‰ΩøÁî®ÁªüËÆ°‰ø°ÊÅØ"""
        from datetime import datetime, timezone
        
        now = datetime.now(timezone.utc)
        days_in_month = (now.replace(month=now.month+1 if now.month < 12 else 1, 
                                   year=now.year if now.month < 12 else now.year+1, day=1) - 
                        self.month_start_time).days if self.month_start_time else 30
        days_remaining = days_in_month - now.day + 1
        
        return {
            "current_cu_rate": self.current_cu_rate,
            "monthly_usage": self.current_month_usage,
            "monthly_limit": self.monthly_cu_limit,
            "monthly_remaining": self.monthly_cu_limit - self.current_month_usage,
            "usage_percentage": (self.current_month_usage / self.monthly_cu_limit) * 100,
            "daily_budget": self.daily_cu_budget,
            "today_usage": self.today_usage,
            "days_remaining": days_remaining,
            "days_in_month": days_in_month
        }
    
    def _get_rpc_url(self, chain_config: Dict) -> str:
        """Ëé∑ÂèñRPC URLÔºåÊõøÊç¢‰∏∫ÂΩìÂâçAPIÂØÜÈí•"""
        base_url = chain_config.get('rpc_url', '').strip()
        
        # ÊõøÊç¢URL‰∏≠ÁöÑPLACEHOLDER_API_KEY‰∏∫ÂΩìÂâçÂÆû‰æãÁöÑÂØÜÈí•
        if 'PLACEHOLDER_API_KEY' in base_url:
            return base_url.replace('PLACEHOLDER_API_KEY', self.api_key)
        
        # ÂÖºÂÆπÊóßÁöÑÊõøÊç¢ÊñπÂºè
        if '/v2/' in base_url:
            parts = base_url.split('/v2/')
            if len(parts) == 2:
                return f"{parts[0]}/v2/{self.api_key}"
        
        return base_url
    
    async def check_asset_transfers(self, address: str, chain_config: Dict) -> Tuple[bool, int]:
        """Ê£ÄÊü•Âú∞ÂùÄÊòØÂê¶Êúâ‰∫§ÊòìÂéÜÂè≤ÔºåËøîÂõû(ÊòØÂê¶Êúâ‰∫§Êòì, ‰∫§ÊòìÊï∞Èáè)"""
        await self._rate_limit(15)  # alchemy_getAssetTransfers Ê∂àËÄóÁ∫¶15 CU
        
        url = self._get_rpc_url(chain_config)
        
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "alchemy_getAssetTransfers",
            "params": [
                {
                    "fromBlock": "0x0",
                    "toBlock": "latest",
                    "fromAddress": address,
                    "category": ["external", "erc20", "erc721", "erc1155"],
                    "maxCount": "0xa"  # Ëé∑ÂèñÊúÄÂ§ö10Êù°ËÆ∞ÂΩïÊù•ÁªüËÆ°
                }
            ]
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data:
                transfers = data['result'].get('transfers', [])
                transfer_count = len(transfers)
                self.record_success()  # ËÆ∞ÂΩïÊàêÂäü
                return transfer_count > 0, transfer_count
            
            self.record_success()  # ËÆ∞ÂΩïÊàêÂäü
            return False, 0
        except requests.exceptions.HTTPError as http_error:
            self.record_failure()  # ËÆ∞ÂΩïÂ§±Ë¥•
            status_code = getattr(http_error.response, 'status_code', None)
            # ÂØπ‰∫é 400/403/404/429ÔºåËßÜ‰∏∫ËØ•ÈìæÂú® Alchemy ‰∏ä‰∏çÂèóÊîØÊåÅÊàñÂØÜÈí•Êú™ÂºÄÈÄö
            if status_code in (400, 403, 404, 429):
                print_warning(f"üö´ {chain_config['name']} Âú®Alchemy‰∏ä‰∏çÂèØÁî® (HTTP {status_code})ÔºåÂ∑≤Ë∑≥Ëøá")
                return False, 0
            # ÂÖ∂ÂÆÉHTTPÈîôËØØÔºå‰øùÂÆàÂ§ÑÁêÜ‰∏∫ÊöÇ‰∏çÂ±èËîΩ
            logging.debug(f"Ê£ÄÊü•‰∫§ÊòìÂéÜÂè≤Â§±Ë¥• {chain_config['name']} (HTTP {status_code}): {http_error}")
            return True, 0
        except Exception as e:
            self.record_failure()  # ËÆ∞ÂΩïÂ§±Ë¥•
            # ÁΩëÁªúË∂ÖÊó∂Á≠âÊöÇÊó∂ÊÄßÈîôËØØÔºå‰∏çÂ±èËîΩ
            logging.warning(f"Ê£ÄÊü•‰∫§ÊòìÂéÜÂè≤Â§±Ë¥• {chain_config['name']}: {e}")
            return True, 0  # ÁΩëÁªúÈîôËØØÊó∂ÂÅáËÆæÊúâ‰∫§ÊòìÂéÜÂè≤ÔºåÈÅøÂÖçËØØÂ±èËîΩ
    
    async def get_balance(self, address: str, chain_config: Dict) -> float:
        """Ëé∑ÂèñÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù"""
        await self._rate_limit(5)  # eth_getBalance Ê∂àËÄóÁ∫¶5 CU
        
        url = self._get_rpc_url(chain_config)
        
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "eth_getBalance",
            "params": [address, "latest"]
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data:
                balance_wei = int(data['result'], 16)
                balance_eth = Web3.from_wei(balance_wei, 'ether')
                self.record_success()  # ËÆ∞ÂΩïÊàêÂäü
                return float(balance_eth)
            
            self.record_success()  # ËÆ∞ÂΩïÊàêÂäü
            return 0.0
        except requests.exceptions.HTTPError as http_error:
            self.record_failure()  # ËÆ∞ÂΩïÂ§±Ë¥•
            status_code = getattr(http_error.response, 'status_code', None)
            if status_code in (400, 403, 404, 429):
                # ‰∏çÊîØÊåÅÁöÑÈìæÔºåÈùôÈªòË∑≥ËøáÔºåÈÅøÂÖçÈáçÂ§çÈîôËØØÊó•Âøó
                return 0.0
            logging.error(f"Ëé∑Âèñ‰ΩôÈ¢ùÂ§±Ë¥• {chain_config['name']}: {http_error}")
            return 0.0
        except Exception as e:
            self.record_failure()  # ËÆ∞ÂΩïÂ§±Ë¥•
            logging.error(f"Ëé∑Âèñ‰ΩôÈ¢ùÂ§±Ë¥• {chain_config['name']}: {e}")
            return 0.0
    
    async def get_all_token_balances(self, address: str, chain_config: Dict) -> Dict[str, Dict]:
        """Ëé∑ÂèñÂú∞ÂùÄÁöÑÊâÄÊúâ‰ª£Â∏Å‰ΩôÈ¢ùÔºàÂéüÁîü‰ª£Â∏Å+ERC-20Ôºâ"""
        await self._rate_limit(25)  # alchemy_getTokenBalances Ê∂àËÄóÁ∫¶25 CU
        
        url = self._get_rpc_url(chain_config)
        
        # ‰ΩøÁî®AlchemyÁöÑgetTokenBalances APIËé∑ÂèñÊâÄÊúâERC-20‰ª£Â∏Å
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "alchemy_getTokenBalances",
            "params": [address]
        }
        
        all_balances = {}
        
        try:
            # Ëé∑ÂèñÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù
            native_balance = await self.get_balance(address, chain_config)
            if native_balance > 0:
                all_balances['native'] = {
                    'symbol': chain_config['native_token'],
                    'balance': native_balance,
                    'contract_address': None,
                    'decimals': 18,
                    'type': 'native'
                }
            
            # Ëé∑ÂèñERC-20‰ª£Â∏Å‰ΩôÈ¢ù
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data and 'tokenBalances' in data['result']:
                for token in data['result']['tokenBalances']:
                    if token['tokenBalance'] and token['tokenBalance'] != '0x0':
                        contract_address = token['contractAddress']
                        
                        # Ëé∑Âèñ‰ª£Â∏ÅÂÖÉÊï∞ÊçÆ
                        metadata = await self.get_token_metadata(contract_address, chain_config)
                        if metadata:
                            balance_raw = int(token['tokenBalance'], 16)
                            decimals = metadata.get('decimals', 18)
                            balance = balance_raw / (10 ** decimals)
                            
                            if balance > 0:
                                all_balances[contract_address] = {
                                    'symbol': metadata.get('symbol', 'UNKNOWN'),
                                    'balance': balance,
                                    'contract_address': contract_address,
                                    'decimals': decimals,
                                    'type': 'erc20'
                                }
            
            self.record_success()  # ËÆ∞ÂΩïÊàêÂäü
            return all_balances
            
        except requests.exceptions.HTTPError as http_error:
            self.record_failure()  # ËÆ∞ÂΩïÂ§±Ë¥•
            status_code = getattr(http_error.response, 'status_code', None)
            if status_code in (400, 403, 404, 429):
                # ‰∏çÊîØÊåÅÁöÑÈìæÔºåÈùôÈªòË∑≥Ëøá
                return {}
            logging.error(f"Ëé∑ÂèñÂÖ®‰ª£Â∏Å‰ΩôÈ¢ùÂ§±Ë¥• {chain_config['name']}: {http_error}")
            return {}
        except Exception as e:
            self.record_failure()  # ËÆ∞ÂΩïÂ§±Ë¥•
            logging.error(f"Ëé∑ÂèñÂÖ®‰ª£Â∏Å‰ΩôÈ¢ùÂ§±Ë¥• {chain_config['name']}: {e}")
            # Â¶ÇÊûúAPIÂ§±Ë¥•ÔºåËá≥Â∞ëËøîÂõûÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù
            native_balance = await self.get_balance(address, chain_config)
            if native_balance > 0:
                return {
                    'native': {
                        'symbol': chain_config['native_token'],
                        'balance': native_balance,
                        'contract_address': None,
                        'decimals': 18,
                        'type': 'native'
                    }
                }
            return {}
    
    async def get_token_metadata(self, contract_address: str, chain_config: Dict) -> Dict:
        """Ëé∑ÂèñERC-20‰ª£Â∏ÅÂÖÉÊï∞ÊçÆ"""
        await self._rate_limit(10)  # alchemy_getTokenMetadata Ê∂àËÄóÁ∫¶10 CU
        
        url = self._get_rpc_url(chain_config)
        
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "alchemy_getTokenMetadata",
            "params": [contract_address]
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data:
                self.record_success()  # ËÆ∞ÂΩïÊàêÂäü
                return data['result']
            
            self.record_success()  # ËÆ∞ÂΩïÊàêÂäü
            return {}
        except Exception as e:
            self.record_failure()  # ËÆ∞ÂΩïÂ§±Ë¥•
            logging.warning(f"Ëé∑Âèñ‰ª£Â∏ÅÂÖÉÊï∞ÊçÆÂ§±Ë¥• {contract_address}: {e}")
            return {}
    

    
    async def get_gas_price(self, chain_config: Dict) -> Dict:
        """Ëé∑ÂèñÂÆûÊó∂gas‰ª∑Ê†º"""
        await self._rate_limit(10)  # eth_feeHistory/eth_gasPrice Ê∂àËÄóÁ∫¶10 CU
        
        url = self._get_rpc_url(chain_config)
        
        # Â∞ùËØïËé∑ÂèñEIP-1559 gas‰ª∑Ê†º
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "eth_feeHistory",
            "params": ["0x1", "latest", [50]]  # Ëé∑ÂèñÊúÄËøë1‰∏™ÂùóÔºå50%ÂàÜ‰ΩçÊï∞
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data:
                result = data['result']
                base_fee = int(result['baseFeePerGas'][0], 16)
                priority_fee = int(result['reward'][0][0], 16) if result['reward'] else 2000000000  # 2 gwei
                
                # opBNBÁâπÊÆäÂ§ÑÁêÜÔºö‰ΩøÁî®Ë∂Ö‰Ωégas‰ª∑Ê†ºÊ®°‰ªøOKXÁ≠ñÁï•
                if chain_config['chain_id'] == 204:  # opBNB
                    base_fee = 101000  # Ë∂Ö‰Ωé0.000101 gweiÔºåÊ®°‰ªøOKXÁ≠ñÁï•
                    priority_fee = 0
                    print_info(f"üí° opBNBË∂Ö‰ΩégasÊ®°Âºè: {base_fee/1e9:.6f} gwei (Ê®°‰ªøOKX)")
                
                self.record_success()  # ËÆ∞ÂΩïÊàêÂäü
                return {
                    "base_fee": base_fee,
                    "priority_fee": priority_fee,
                    "max_fee": base_fee + priority_fee,
                    "gas_price": base_fee + priority_fee
                }
        except:
            pass
        
        # ÂõûÈÄÄÂà∞‰º†Áªügas‰ª∑Ê†º
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "eth_gasPrice",
            "params": []
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data:
                gas_price = int(data['result'], 16)
                
                # opBNBÁâπÊÆäÂ§ÑÁêÜÔºö‰ΩøÁî®Ë∂Ö‰Ωégas‰ª∑Ê†ºÊ®°‰ªøOKXÁ≠ñÁï•
                if chain_config['chain_id'] == 204:  # opBNB
                    gas_price = 101000  # Ë∂Ö‰Ωé0.000101 gweiÔºåÊ®°‰ªøOKXÁ≠ñÁï•
                    print_info(f"üí° opBNBË∂Ö‰ΩégasÊ®°Âºè: {gas_price/1e9:.6f} gwei (Ê®°‰ªøOKX)")
                
                # Á°Æ‰øùgas‰ª∑Ê†º‰∏ç‰∏∫Èõ∂
                if gas_price > 0:
                    self.record_success()  # ËÆ∞ÂΩïÊàêÂäü
                    return {
                        "gas_price": gas_price,
                        "max_fee": gas_price,
                        "base_fee": gas_price,
                        "priority_fee": 0
                    }
                else:
                    print_warning(f"Gas‰ª∑Ê†º‰∏∫0Ôºå‰ΩøÁî®ÊúÄÂ∞èÂÄº {chain_config['name']}")
                    # opBNBÈìæ‰ΩøÁî®Ë∂Ö‰Ωégas‰ª∑Ê†º
                    if chain_config['chain_id'] == 204:  # opBNB
                        gas_price = 101000  # Ë∂Ö‰Ωé0.000101 gweiÔºåÊ®°‰ªøOKXÁ≠ñÁï•
                    else:
                        gas_price = 1000000000  # 1 gwei minimum
                    self.record_success()  # ËÆ∞ÂΩïÊàêÂäü
                    return {
                        "gas_price": gas_price,
                        "max_fee": gas_price,
                        "base_fee": gas_price,
                        "priority_fee": 0
                    }
        except Exception as e:
            self.record_failure()  # ËÆ∞ÂΩïÂ§±Ë¥•
            logging.error(f"Ëé∑Âèñgas‰ª∑Ê†ºÂ§±Ë¥• {chain_config['name']}: {e}")
            
        # ÈªòËÆ§gas‰ª∑Ê†º - Á°Æ‰øù‰∏ç‰∏∫Èõ∂
        if chain_config['chain_id'] == 204:  # opBNB
            default_gas = 101000  # Ë∂Ö‰Ωé0.000101 gweiÔºåÊ®°‰ªøOKXÁ≠ñÁï•
        else:
            default_gas = 20000000000  # 20 gwei
        print_warning(f"‰ΩøÁî®ÈªòËÆ§gas‰ª∑Ê†º {chain_config['name']}: {default_gas/1e9:.6f} gwei")
        return {
            "gas_price": default_gas,
            "max_fee": default_gas,
            "base_fee": default_gas,
            "priority_fee": 0
        }

class TransferManager:
    """ËΩ¨Ë¥¶ÁÆ°ÁêÜÁ±ª"""
    
    def __init__(self, alchemy_api: AlchemyAPI, db_manager: DatabaseManager, monitoring_app=None):
        self.alchemy_api = alchemy_api
        self.db_manager = db_manager
        self.web3_instances = {}
        self.monitoring_app = monitoring_app
        self._connection_cleanup_interval = 3600  # 1Â∞èÊó∂Ê∏ÖÁêÜ‰∏ÄÊ¨°ËøûÊé•
        self._last_cleanup = time.time()
    
    def _cleanup_stale_connections(self):
        """Ê∏ÖÁêÜËøáÊó∂ÁöÑWeb3ËøûÊé•"""
        current_time = time.time()
        if current_time - self._last_cleanup > self._connection_cleanup_interval:
            # Ê∏ÖÁêÜÊâÄÊúâÁºìÂ≠òÁöÑËøûÊé•ÔºåÂº∫Âà∂ÈáçÊñ∞ÂàõÂª∫
            self.web3_instances.clear()
            self._last_cleanup = current_time
            print_info("üßπ Â∑≤Ê∏ÖÁêÜWeb3ËøûÊé•ÁºìÂ≠ò")
    
    def get_web3_instance(self, chain_config: Dict) -> Web3:
        """Ëé∑ÂèñWeb3ÂÆû‰æã"""
        chain_name = chain_config['name']
        
        # ÂÆöÊúüÊ∏ÖÁêÜËøûÊé•
        self._cleanup_stale_connections()
        
        if chain_name not in self.web3_instances:
            # ÂÖºÂÆπË¥üËΩΩÂùáË°°Âô®‰∏éÂçïÂÆû‰æã‰∏§ÁßçÊ®°Âºè
            try:
                if hasattr(self.alchemy_api, '_get_rpc_url'):
                    rpc_url = self.alchemy_api._get_rpc_url(chain_config)
                elif hasattr(self.alchemy_api, 'get_next_api'):
                    api = self.alchemy_api.get_next_api()
                    rpc_url = api._get_rpc_url(chain_config)
                else:
                    rpc_url = chain_config.get('rpc_url', '')
            except Exception:
                rpc_url = chain_config.get('rpc_url', '')
            
            try:
                # ÂàõÂª∫HTTPÊèê‰æõËÄÖÔºåËÆæÁΩÆË∂ÖÊó∂
                provider = Web3.HTTPProvider(
                    rpc_url,
                    request_kwargs={'timeout': 30}
                )
                web3 = Web3(provider)
                
                # ‰∏∫Êüê‰∫õÈìæÊ∑ªÂä†POA‰∏≠Èó¥‰ª∂
                if chain_config['chain_id'] in [56, 137, 250, 43114, 59144]:  # BSC, Polygon, Fantom, Avalanche, Linea
                    try:
                        # Â∞ùËØïÊñ∞ÁâàÊú¨ÁöÑ‰∏≠Èó¥‰ª∂Ê≥®ÂÖ•ÊñπÂºè
                        if callable(geth_poa_middleware):
                            if hasattr(web3.middleware_onion, 'inject'):
                                web3.middleware_onion.inject(geth_poa_middleware, layer=0)
                            else:
                                # ÂÖºÂÆπÊõ¥Êñ∞ÁöÑÁâàÊú¨
                                web3.middleware_onion.add(geth_poa_middleware)
                    except Exception as e:
                        logging.debug(f"POA‰∏≠Èó¥‰ª∂Ê≥®ÂÖ•Â§±Ë¥•: {e}")
                        # ÁªßÁª≠ÊâßË°åÔºå‰∏çÂΩ±Âìç‰∏ªË¶ÅÂäüËÉΩ
                
                # ÊµãËØïËøûÊé•
                try:
                    # ËøûÊé•ÊÄßÊ£ÄÊü•
                    web3.is_connected()
                except Exception as e:
                    logging.debug(f"Web3ËøûÊé•ÊµãËØïÂ§±Ë¥• {chain_name}: {e}")
                
                self.web3_instances[chain_name] = web3
                
            except Exception as e:
                logging.error(f"ÂàõÂª∫Web3ÂÆû‰æãÂ§±Ë¥• {chain_name}: {e}")
                # ÂàõÂª∫‰∏Ä‰∏™Âü∫Êú¨ÁöÑWeb3ÂÆû‰æã‰Ωú‰∏∫ÂêéÂ§á
                web3 = Web3(Web3.HTTPProvider(rpc_url))
                self.web3_instances[chain_name] = web3
        
        return self.web3_instances[chain_name]
    
    async def estimate_smart_gas(self, from_address: str, to_address: str, 
                                balance_wei: int, chain_config: Dict, 
                                is_erc20: bool = False) -> Tuple[int, int, int]:
        """Êô∫ËÉΩgas‰º∞ÁÆó - Á°Æ‰øùÂ∞ëÈáè‰ΩôÈ¢ù‰πüËÉΩËΩ¨Ë¥¶"""
        web3 = self.get_web3_instance(chain_config)
        
        try:
            # Ëé∑Âèñgas‰ª∑Ê†º
            gas_data = await self.alchemy_api.get_gas_price(chain_config)
            
            # Ê†πÊçÆ‰ª£Â∏ÅÁ±ªÂûãÂíåÈìæËÆæÁΩÆgas limit
            if is_erc20:
                if chain_config['chain_id'] == 324:  # ZKsync Era
                    base_gas_limit = 200000  # ZKsync ERC-20ÈúÄË¶ÅÊõ¥Â§ögas
                else:
                    base_gas_limit = 65000  # ERC-20ËΩ¨Ë¥¶Âü∫Á°Ägas
            else:
                if chain_config['chain_id'] in [421614, 42161]:  # Arbitrum Sepolia/One
                    base_gas_limit = 50000  # ArbitrumÈúÄË¶ÅÊõ¥Â§ögas
                elif chain_config['chain_id'] == 324:  # ZKsync Era
                    base_gas_limit = 150000  # ZKsyncÂéüÁîüËΩ¨Ë¥¶ÈúÄË¶ÅÊõ¥Â§ögas
                else:
                    base_gas_limit = 21000  # ÂéüÁîü‰ª£Â∏ÅËΩ¨Ë¥¶Âü∫Á°Ägas
            
            # Ëé∑ÂèñÂü∫Á°Ägas‰ª∑Ê†º
            if chain_config['chain_id'] == 204:  # opBNB
                base_gas_price = gas_data.get('gas_price', 101000)  # Ë∂Ö‰Ωé0.000101 gweiÔºåÊ®°‰ªøOKX
                if base_gas_price <= 0:
                    base_gas_price = 101000  # Â¶ÇÊûú‰ª∑Ê†º‰∏∫Èõ∂Ôºå‰ΩøÁî®Ë∂Ö‰Ωé‰ª∑Ê†º
            else:
                base_gas_price = gas_data.get('gas_price', 20000000000)  # ÈªòËÆ§20 gwei
                if base_gas_price <= 0:
                    base_gas_price = 20000000000  # Â¶ÇÊûú‰ª∑Ê†º‰∏∫Èõ∂Ôºå‰ΩøÁî®20 gwei
            
            # üéØ Á≤âÂ∞òÈáëÈ¢ùÁâπÊÆäÂ§ÑÁêÜÔºö‰ΩøÁî®ÂêàÁêÜÁöÑ‰Ωégas‰ª∑Ê†º
            dust_threshold = Web3.to_wei(0.001, 'ether')  # 0.001 ETH‰ª•‰∏ãËßÜ‰∏∫Á≤âÂ∞ò
            
            if not is_erc20 and balance_wei <= dust_threshold:
                print_info(f"üí® Ê£ÄÊµãÂà∞Á≤âÂ∞òÈáëÈ¢ùÔºåÂêØÁî®Êô∫ËÉΩ‰ΩégasÊ®°Âºè")
                
                # Ëé∑ÂèñÂΩìÂâçÁΩëÁªúÁöÑÂü∫Á°ÄË¥πÁî®ÔºåÁ°Æ‰øùÊàë‰ª¨ÁöÑgas‰ª∑Ê†º‰∏ç‰ºöÂ§™‰Ωé
                try:
                    latest_block = web3.eth.get_block('latest')
                    base_fee = getattr(latest_block, 'baseFeePerGas', None)
                    if base_fee:
                        # ‰ΩøÁî®Âü∫Á°ÄË¥πÁî®ÁöÑ1.1ÂÄç‰Ωú‰∏∫ÊúÄ‰Ωé‰ª∑Ê†ºÔºåÁ°Æ‰øù‰∫§ÊòìËÉΩË¢´Êé•Âèó
                        min_gas_price = max(int(base_fee * 1.1), base_gas_price // 5)
                        print_info(f"üìä ÁΩëÁªúÂü∫Á°ÄË¥πÁî®: {base_fee/1e9:.3f} gweiÔºåË∞ÉÊï¥‰∏∫: {min_gas_price/1e9:.3f} gwei")
                    else:
                        # Â¶ÇÊûúÊ≤°ÊúâÂü∫Á°ÄË¥πÁî®‰ø°ÊÅØÔºå‰ΩøÁî®‰øùÂÆàÁöÑ‰Ωé‰ª∑Ê†º
                        if chain_config['chain_id'] == 204:  # opBNB
                            min_gas_price = max(base_gas_price // 5, 50500)  # Ë∂Ö‰Ωé‰ª∑Ê†ºÔºåÊ®°‰ªøOKX
                        else:
                            min_gas_price = max(base_gas_price // 5, 2000000000)  # ÊúÄ‰Ωé2 gwei
                except Exception as e:
                    print_warning(f"Êó†Ê≥ïËé∑ÂèñÂü∫Á°ÄË¥πÁî®: {e}")
                    if chain_config['chain_id'] == 204:  # opBNB
                        min_gas_price = max(base_gas_price // 5, 50500)  # Ë∂Ö‰Ωé‰ª∑Ê†ºÔºåÊ®°‰ªøOKX
                    else:
                        min_gas_price = max(base_gas_price // 5, 2000000000)  # ÊúÄ‰Ωé2 gwei
                
                # ‰ΩøÁî®ÊúÄÂ∞ègas limit
                min_gas_limit = 21000  # Ê†áÂáÜÊúÄÂ∞è
                
                # ËÆ°ÁÆógasÊàêÊú¨
                min_gas_cost = min_gas_limit * min_gas_price
                
                # Ê£ÄÊü•ÊòØÂê¶ËøòÊúâË∂≥Â§ü‰ΩôÈ¢ù
                if balance_wei > min_gas_cost:
                    available_amount = balance_wei - min_gas_cost
                    print_success(f"üíé Êô∫ËÉΩ‰Ωégas: {min_gas_limit} gas * {min_gas_price/1e9:.3f} gwei = {min_gas_cost/1e18:.9f} ETH")
                    return min_gas_limit, min_gas_price, available_amount
                else:
                    # Â¶ÇÊûúËøòÊòØ‰ªò‰∏çËµ∑Ôºå‰ΩøÁî®Êõ¥‰øùÂÆàÁöÑÊñπÊ≥ï
                    try:
                        # Â∞ùËØïËé∑ÂèñÁΩëÁªúÂª∫ËÆÆÁöÑÊúÄ‰Ωégas‰ª∑Ê†º
                        suggested_gas = web3.eth.gas_price
                        conservative_gas_price = max(suggested_gas // 3, min_gas_price)
                        conservative_gas_cost = min_gas_limit * conservative_gas_price
                        
                        if balance_wei > conservative_gas_cost:
                            available_amount = balance_wei - conservative_gas_cost
                            print_warning(f"‚ö° ‰øùÂÆàÊ®°Âºè: {min_gas_limit} gas * {conservative_gas_price/1e9:.3f} gwei = {conservative_gas_cost/1e18:.9f} ETH")
                            return min_gas_limit, conservative_gas_price, available_amount
                    except Exception:
                        pass
                    
                    print_error(f"üíî Á≤âÂ∞òÈáëÈ¢ùËøáÂ∞èÔºåÊó†Ê≥ïÊîØ‰ªòÁΩëÁªúÊúÄ‰ΩégasË¥πÁî®")
                    print_info(f"   ‰ΩôÈ¢ù: {balance_wei/1e18:.9f} ETH")
                    print_info(f"   ÊúÄ‰ΩégasË¥π: {min_gas_cost/1e18:.9f} ETH")
                    print_info(f"   Â∑ÆÈ¢ù: {(min_gas_cost - balance_wei)/1e18:.9f} ETH")
                    
                    # Â¶ÇÊûúÂ∑ÆÈ¢ùÂ§™Â§ßÔºàË∂ÖËøá10ÂÄçÔºâÔºåÂ∞±‰∏çË¶ÅÂ∞ùËØï‰∫Ü
                    if min_gas_cost > balance_wei * 10:
                        print_warning(f"üíÄ ÈáëÈ¢ùËøáÂ∞èÔºåË∑≥ËøáËΩ¨Ë¥¶Â∞ùËØï")
                        return 0, 0, 0
                    
                    # ÂØπ‰∫éÂ∑ÆÈ¢ù‰∏çÂ§ßÁöÑÊÉÖÂÜµÔºåÁªô‰∏Ä‰∏™ÊèêÁ§∫‰ΩÜ‰ªçËøîÂõû0
                    print_info(f"ü§è ÈáëÈ¢ùÊé•ËøëÂèØËΩ¨Ë¥¶ÈòàÂÄºÔºå‰ΩÜ‰ªçÁÑ∂‰∏çË∂≥")
                    return 0, 0, 0
            
            # Ê≠£Â∏∏ÈáëÈ¢ùÂ§ÑÁêÜ
            if chain_config['chain_id'] == 204:  # opBNB
                base_gas_price = max(base_gas_price, 101000)  # Ë∂Ö‰Ωé0.000101 gweiÔºåÊ®°‰ªøOKX
            else:
                base_gas_price = max(base_gas_price, 1000000000)  # Ëá≥Â∞ë1 gwei
            gas_price_multiplier = 1.2
            if chain_config['chain_id'] in [1, 42161, 10]:  # ‰∏ªÁΩë„ÄÅArbitrum„ÄÅOptimism
                gas_price_multiplier = 1.0
            elif chain_config['chain_id'] == 324:  # ZKsync Era
                gas_price_multiplier = 2.0
            elif chain_config['chain_id'] == 204:  # opBNB
                gas_price_multiplier = 1.0  # opBNB gas‰ª∑Ê†ºÊú¨Ë∫´Â∞±Âæà‰ΩéÔºå‰∏çÈúÄË¶ÅÈ¢ùÂ§ñÂÄçÊï∞
            
            gas_price = int(base_gas_price * gas_price_multiplier)
            
            # ËÆ°ÁÆógasÊàêÊú¨
            total_gas_cost = base_gas_limit * gas_price
            
            # Êô∫ËÉΩ‰ΩôÈ¢ùÂàÜÈÖçÔºö‰∏∫ÂéüÁîü‰ª£Â∏ÅÈ¢ÑÁïôgasË¥πÁî®
            if not is_erc20:
                # ÂéüÁîü‰ª£Â∏ÅÈúÄË¶ÅÈ¢ÑÁïôgasË¥πÁî®
                available_amount = max(0, balance_wei - total_gas_cost)
                if available_amount <= 0:
                    print_warning(f"‰ΩôÈ¢ù‰∏çË∂≥ÊîØ‰ªògasË¥πÁî® {chain_config['name']}")
                    return 0, 0, 0
            else:
                # ERC-20‰ª£Â∏Å‰ΩøÁî®ÂÖ®ÈÉ®‰ΩôÈ¢ù
                available_amount = balance_wei
            
            print_gas(f"‚õΩ Gas‰º∞ÁÆó {chain_config['name']}: {base_gas_limit} gas * {gas_price/1e9:.2f} gwei = {total_gas_cost/1e18:.6f} {chain_config['native_token']}")
            
            return base_gas_limit, gas_price, available_amount
            
        except Exception as e:
            print_error(f"Gas‰º∞ÁÆóÂ§±Ë¥• {chain_config['name']}: {e}")
            # ËøîÂõû‰øùÂÆàÁöÑÈªòËÆ§ÂÄº
            return 21000, 20000000000, max(0, balance_wei - 21000 * 20000000000)
    
    async def send_native_transaction(self, private_key: str, from_address: str, 
                                     to_address: str, amount: float, chain_config: Dict,
                                     max_retries: int = 3) -> Dict:
        """ÂèëÈÄÅÂéüÁîü‰ª£Â∏Å‰∫§Êòì"""
        web3 = self.get_web3_instance(chain_config)
        account = Account.from_key(private_key)
        
        for retry in range(max_retries):
            try:
                # Ëé∑Âèñnonce
                nonce = web3.eth.get_transaction_count(from_address)
                
                # ËΩ¨Êç¢ÈáëÈ¢ù‰∏∫wei
                amount_wei = Web3.to_wei(amount, 'ether')
                
                # Êô∫ËÉΩgas‰º∞ÁÆó
                balance_wei = web3.eth.get_balance(from_address)
                gas_limit, gas_price, available_amount = await self.estimate_smart_gas(
                    from_address, to_address, balance_wei, chain_config, False
                )
                
                # Ê£ÄÊü•Êô∫ËÉΩgas‰º∞ÁÆóÁªìÊûú
                total_needed = gas_limit * gas_price
                
                # ‰øÆÂ§çÔºöÂ¶ÇÊûúgas‰ª∑Ê†º‰∏∫0Ôºå‰ΩøÁî®ÊúÄÂ∞ègas‰ª∑Ê†º
                if gas_price <= 0:
                    if chain_config['chain_id'] == 204:  # opBNB
                        gas_price = 101000  # Ë∂Ö‰Ωé0.000101 gweiÔºåÊ®°‰ªøOKX
                    else:
                        gas_price = 1000000000  # 1 gwei ÊúÄÂ∞èÂÄº
                    total_needed = gas_limit * gas_price
                    print_warning(f"Gas‰ª∑Ê†ºÂºÇÂ∏∏Ôºå‰ΩøÁî®ÊúÄÂ∞èÂÄº: {gas_price/1e9:.6f} gwei")
                
                # üéØ Á≤âÂ∞òÈáëÈ¢ùËá™Âä®ÈáçÊñ∞ËÆ°ÁÆógasÂèÇÊï∞
                if balance_wei <= Web3.to_wei(0.001, 'ether'):
                    print_info(f"üí® Á≤âÂ∞òÈáëÈ¢ùÈáçÊñ∞ËÆ°ÁÆógasÂèÇÊï∞...")
                    gas_limit, gas_price, available_amount = await self.estimate_smart_gas(
                        from_address, to_address, balance_wei, chain_config, False
                    )
                    total_needed = gas_limit * gas_price
                    if available_amount > 0:
                        print_success(f"‚úÖ Á≤âÂ∞ò‰ºòÂåñÊàêÂäüÔºåÂèØËΩ¨Ë¥¶ÈáëÈ¢ù: {available_amount/1e18:.9f} ETH")
                
                if available_amount <= 0 or balance_wei < total_needed:
                    logging.warning(f"‰ΩôÈ¢ù‰∏çË∂≥‰ª•ÊîØ‰ªògasË¥πÁî® {chain_config['name']}: ‰ΩôÈ¢ù {balance_wei/1e18:.9f}, gasË¥πÁî® {total_needed/1e18:.9f}")
                    print_warning(f"ÂèñÊ∂àÈáçËØï {chain_config['name']}: ‰ΩôÈ¢ù‰∏çË∂≥‰ª•ÊîØ‰ªògasË¥πÁî®")
                    return {
                        "success": False,
                        "error": f"‰ΩôÈ¢ù‰∏çË∂≥‰ª•ÊîØ‰ªògasË¥πÁî®: ‰ΩôÈ¢ù {balance_wei} wei, ÈúÄË¶Å {total_needed} wei",
                        "type": "native",
                        "skip_retry": True  # Ê†áËÆ∞Ë∑≥ËøáÈáçËØï
                    }
                
                # ‰ΩøÁî®Êô∫ËÉΩËÆ°ÁÆóÁöÑÂèØÁî®ÈáëÈ¢ù
                amount_wei = available_amount
                
                # ÊûÑÂª∫‰∫§ÊòìÔºà‰ΩøÁî®Êô∫ËÉΩgas‰ª∑Ê†ºÔºâ
                transaction = {
                    'nonce': nonce,
                    'to': Web3.to_checksum_address(to_address),
                    'value': amount_wei,
                    'gas': gas_limit,
                    'gasPrice': gas_price,
                    'chainId': chain_config['chain_id']
                }
                
                # Á≠æÂêç‰∫§Êòì
                signed_txn = account.sign_transaction(transaction)
                
                # ÂèëÈÄÅ‰∫§Êòì
                tx_hash = web3.eth.send_raw_transaction(signed_txn.rawTransaction)
                tx_hash_hex = tx_hash.hex()
                
                # Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§
                receipt = web3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)
                
                # ËÆ∞ÂΩïÊàêÂäüÁöÑËΩ¨Ë¥¶
                await self.db_manager.log_transfer(
                    from_address, chain_config['name'], chain_config['chain_id'],
                    str(Web3.from_wei(amount_wei, 'ether')), to_address,
                    tx_hash_hex, str(receipt.gasUsed), str(gas_price),
                    "success"
                )
                
                return {
                    "success": True,
                    "tx_hash": tx_hash_hex,
                    "amount": Web3.from_wei(amount_wei, 'ether'),
                    "gas_used": receipt.gasUsed,
                    "gas_price": gas_price,
                    "type": "native"
                }
                
            except Exception as e:
                error_msg = str(e)
                logging.error(f"ÂéüÁîü‰ª£Â∏ÅËΩ¨Ë¥¶Â§±Ë¥• (ÈáçËØï {retry + 1}/{max_retries}) {chain_config['name']}: {error_msg}")
                
                # Ê£ÄÊü•ÊòØÂê¶ÊòØ‰ΩôÈ¢ù‰∏çË∂≥ÈîôËØØÔºåÂ¶ÇÊûúÊòØÂàôÁõ¥Êé•Ë∑≥Âá∫ÈáçËØï
                if "insufficient funds" in error_msg.lower() or "‰ΩôÈ¢ù‰∏çË∂≥" in error_msg:
                    translated_error = translate_error_message(error_msg)
                    print_error(f"‚ùå NATIVEËΩ¨Ë¥¶Â§±Ë¥•: {translated_error}")
                    print_warning(f"ÂèñÊ∂àÈáçËØï {chain_config['name']}: ‰ΩôÈ¢ù‰∏çË∂≥")
                    await self.db_manager.log_transfer(
                        from_address, chain_config['name'], chain_config['chain_id'],
                        str(amount), to_address, status="failed", error_message=error_msg
                    )
                    return {
                        "success": False,
                        "error": error_msg,
                        "type": "native"
                    }
                
                if retry == max_retries - 1:
                    # ËÆ∞ÂΩïÂ§±Ë¥•ÁöÑËΩ¨Ë¥¶
                    await self.db_manager.log_transfer(
                        from_address, chain_config['name'], chain_config['chain_id'],
                        str(amount), to_address, status="failed", error_message=error_msg
                    )
                    
                    return {
                        "success": False,
                        "error": error_msg,
                        "retry_count": max_retries,
                        "type": "native"
                    }
                
                # Á≠âÂæÖ5ÁßíÂêéÈáçËØï
                await asyncio.sleep(5)
        
        return {"success": False, "error": "ËææÂà∞ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞", "type": "native"}
    
    async def send_erc20_transaction(self, private_key: str, from_address: str, 
                                   to_address: str, token_info: Dict, chain_config: Dict,
                                   max_retries: int = 3) -> Dict:
        """ÂèëÈÄÅERC-20‰ª£Â∏Å‰∫§Êòì"""
        web3 = self.get_web3_instance(chain_config)
        account = Account.from_key(private_key)
        
        # ERC-20 ABI‰∏≠ÁöÑtransferÂáΩÊï∞
        erc20_abi = [
            {
                "constant": False,
                "inputs": [
                    {"name": "_to", "type": "address"},
                    {"name": "_value", "type": "uint256"}
                ],
                "name": "transfer",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            }
        ]
        
        for retry in range(max_retries):
            try:
                # Ëé∑Âèñnonce
                nonce = web3.eth.get_transaction_count(from_address)
                
                # ÂàõÂª∫ÂêàÁ∫¶ÂÆû‰æã
                contract = web3.eth.contract(
                    address=Web3.to_checksum_address(token_info['contract_address']),
                    abi=erc20_abi
                )
                
                # ËÆ°ÁÆóËΩ¨Ë¥¶ÈáëÈ¢ùÔºàËΩ¨Âá∫ÊâÄÊúâ‰ΩôÈ¢ùÔºâÔºåÂπ∂Á°Æ‰øùËá≥Â∞ë‰∏∫1‰∏™ÊúÄÂ∞èÂçï‰Ωç
                decimals = int(token_info['decimals']) if 'decimals' in token_info else 18
                amount_raw = int(Decimal(str(token_info['balance'])) * (10 ** decimals))
                if amount_raw <= 0:
                    raise ValueError("‰ª£Â∏Å‰ΩôÈ¢ùËøáÂ∞èÔºåÊó†Ê≥ïÂΩ¢ÊàêÊúâÊïàÊúÄÂ∞èÂçï‰ΩçÔºåË∑≥Ëøá‰∫§Êòì")
                
                # Ê†πÊçÆÈìæËÆæÁΩÆÈÄÇÂΩìÁöÑgas limit
                if chain_config['chain_id'] == 324:  # ZKsync Era
                    gas_limit = 200000
                elif chain_config['chain_id'] in [421614, 42161]:  # Arbitrum
                    gas_limit = 150000
                else:
                    gas_limit = 100000
                
                # ÊûÑÂª∫‰∫§ÊòìÊï∞ÊçÆ - ‰∏çÂåÖÂê´gas‰ª∑Ê†º
                base_transaction = {
                    'chainId': chain_config['chain_id'],
                    'gas': gas_limit,
                    'nonce': nonce,
                }
                
                try:
                    transaction_data = contract.functions.transfer(
                        Web3.to_checksum_address(to_address),
                        amount_raw
                    ).build_transaction(base_transaction)
                except AttributeError:
                    # ÂÖºÂÆπ‰∏çÂêåÁâàÊú¨ÁöÑWeb3
                    transaction_data = contract.functions.transfer(
                        Web3.to_checksum_address(to_address),
                        amount_raw
                    ).buildTransaction(base_transaction)
                
                # Ê£ÄÊü•ÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ùÊòØÂê¶Ë∂≥Â§üÊîØ‰ªògas
                native_balance = web3.eth.get_balance(from_address)
                
                # Ëé∑Âèñgas‰ª∑Ê†º
                gas_data = await self.alchemy_api.get_gas_price(chain_config)
                
                # ËÆ°ÁÆógasË¥πÁî®Ôºà‰ΩøÁî®ËÆæÁΩÆÁöÑgas limitÔºâ
                estimated_gas_cost = gas_limit * gas_data['gas_price']
                
                if native_balance < estimated_gas_cost:
                    # üéØ Êô∫ËÉΩgasË¥πÁî®‰ºòÂåñÂ∞ùËØï
                    print_warning(f"ÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù‰∏çË∂≥ÔºåÂ∞ùËØï‰ºòÂåñgasË¥πÁî®...")
                    
                    try:
                        # Â∞ùËØï‰ΩøÁî®ÊúÄ‰ΩégasË¥πÁî®Ê®°Âºè
                        min_gas_limit = 65000  # ERC-20ËΩ¨Ë¥¶ÊúÄÂ∞ègas limit
                        
                        # Ëé∑ÂèñÁΩëÁªúÂü∫Á°ÄË¥πÁî®
                        try:
                            latest_block = web3.eth.get_block('latest')
                            base_fee = getattr(latest_block, 'baseFeePerGas', None)
                            if base_fee:
                                min_gas_price = int(base_fee * 1.1)  # Âü∫Á°ÄË¥πÁî®1.1ÂÄç
                            else:
                                min_gas_price = gas_data['gas_price'] // 5  # Âéü‰ª∑Ê†ºÁöÑ1/5
                        except Exception:
                            min_gas_price = gas_data['gas_price'] // 5
                        
                        if chain_config['chain_id'] == 204:  # opBNB
                            min_gas_price = max(min_gas_price, 101000)  # Ë∂Ö‰Ωé0.000101 gweiÔºåÊ®°‰ªøOKX
                        else:
                            min_gas_price = max(min_gas_price, 1000000000)  # ÊúÄ‰Ωé1 gwei
                        min_estimated_cost = min_gas_limit * min_gas_price
                        
                        if native_balance >= min_estimated_cost:
                            print_success(f"üíé ÂêØÁî®‰ΩégasÊ®°Âºè: {min_gas_limit} gas * {min_gas_price/1e9:.3f} gwei")
                            transaction_data['gas'] = min_gas_limit
                            
                            # Êõ¥Êñ∞gas‰ª∑Ê†º
                            if 'gasPrice' in transaction_data:
                                transaction_data['gasPrice'] = min_gas_price
                            elif 'maxFeePerGas' in transaction_data:
                                transaction_data['maxFeePerGas'] = min_gas_price
                                transaction_data['maxPriorityFeePerGas'] = min(min_gas_price // 10, 1000000000)
                            
                            estimated_gas_cost = min_estimated_cost
                        else:
                            # Ê£ÄÊü•ERC20‰ª£Â∏Å‰ª∑ÂÄºÔºåÂè™Êúâ‰ª∑ÂÄºÂ§ß‰∫é1ÁæéÂÖÉÊâçÂèëÈÄÅÈÄöÁü•
                            token_price = await self.monitoring_app.price_checker.get_token_price_usd(
                                token_info['symbol'], 
                                token_info.get('contract_address')
                            ) if self.monitoring_app else None
                            
                            token_value_usd = (token_info['balance'] * token_price) if token_price else 0
                            
                            if token_value_usd >= 1.0:  # Âè™Êúâ‰ª∑ÂÄº>=1ÁæéÂÖÉÊâçÂèëÈÄÅÈÄöÁü•
                                await self._send_erc20_gas_shortage_notification(
                                    from_address, token_info, chain_config, 
                                    min_estimated_cost, native_balance, token_price, token_value_usd,
                                    TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID
                                )
                            else:
                                print_info(f"üí° ERC20‰ª£Â∏Å {token_info['symbol']} ‰ª∑ÂÄºËøá‰Ωé (${token_value_usd:.4f})ÔºåË∑≥ËøáÈÄöÁü•")
                            
                            raise ValueError(f"ÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù‰∏çË∂≥ÊîØ‰ªògasË¥πÁî®: ÈúÄË¶Å {min_estimated_cost/1e18:.8f} {chain_config['native_token']}, ‰ΩôÈ¢ù {native_balance/1e18:.8f}")
                    
                    except ValueError:
                        # ÈáçÊñ∞ÊäõÂá∫ValueErrorÔºà‰ΩôÈ¢ù‰∏çË∂≥Ôºâ
                        raise
                    except Exception as e:
                        print_warning(f"gas‰ºòÂåñÂ§±Ë¥•: {e}")
                        raise ValueError(f"ÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù‰∏çË∂≥ÊîØ‰ªògasË¥πÁî®: ÈúÄË¶Å {estimated_gas_cost/1e18:.8f} {chain_config['native_token']}, ‰ΩôÈ¢ù {native_balance/1e18:.8f}")
                
                # ÂÆâÂÖ®ËÆæÁΩÆgas‰ª∑Ê†º - ÈÅøÂÖçÂèÇÊï∞ÂÜ≤Á™Å
                try:
                    # ÁßªÈô§ÂèØËÉΩÂÜ≤Á™ÅÁöÑgas‰ª∑Ê†ºÂ≠óÊÆµ
                    if 'gasPrice' in transaction_data:
                        del transaction_data['gasPrice']
                    if 'maxFeePerGas' in transaction_data:
                        del transaction_data['maxFeePerGas']
                    if 'maxPriorityFeePerGas' in transaction_data:
                        del transaction_data['maxPriorityFeePerGas']
                    
                    # ÁâπÊÆäÈìæÂ§ÑÁêÜ
                    if chain_config['chain_id'] == 324:  # ZKsync Era
                        # ZKsync Era‰ΩøÁî®‰º†Áªügas‰ª∑Ê†ºÔºå‰ΩÜÈúÄË¶ÅÁâπÊÆäÁöÑgas‰º∞ÁÆó
                        transaction_data['gasPrice'] = max(gas_data['gas_price'], 25000000)  # ÊúÄÂ∞ë0.025 gwei
                        transaction_data['gas'] = 200000  # ZKsyncÈúÄË¶ÅÊõ¥Â§ögas
                    elif chain_config['chain_id'] == 204:  # opBNB
                        # opBNB‰ΩøÁî®Ë∂Ö‰Ωégas‰ª∑Ê†ºÔºåÊ®°‰ªøOKXÁ≠ñÁï•
                        transaction_data['gasPrice'] = max(gas_data['gas_price'], 101000)  # Ë∂Ö‰Ωé0.000101 gwei
                        transaction_data['gas'] = 21000  # Ê†áÂáÜgasÈôêÂà∂
                    elif 'max_fee' in gas_data and chain_config['chain_id'] in [1, 137, 10, 42161]:
                        # EIP-1559ÊîØÊåÅÁöÑÈìæ
                        transaction_data['maxFeePerGas'] = gas_data['max_fee']
                        transaction_data['maxPriorityFeePerGas'] = gas_data['priority_fee']
                    else:
                        # ‰º†Áªügas‰ª∑Ê†º
                        transaction_data['gasPrice'] = gas_data['gas_price']
                except Exception as e:
                    print_warning(f"ËÆæÁΩÆgas‰ª∑Ê†ºÂá∫ÈîôÔºå‰ΩøÁî®‰º†ÁªüÊñπÂºè: {e}")
                    transaction_data['gasPrice'] = gas_data['gas_price']
                
                # Á≠æÂêç‰∫§Êòì
                signed_txn = account.sign_transaction(transaction_data)
                
                # ÂèëÈÄÅ‰∫§Êòì
                tx_hash = web3.eth.send_raw_transaction(signed_txn.rawTransaction)
                tx_hash_hex = tx_hash.hex()
                
                # Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§
                receipt = web3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)
                
                # ËÆ∞ÂΩïÊàêÂäüÁöÑËΩ¨Ë¥¶
                await self.db_manager.log_transfer(
                    from_address, chain_config['name'], chain_config['chain_id'],
                    f"{token_info['balance']} {token_info['symbol']}", to_address,
                    tx_hash_hex, str(receipt.gasUsed), str(gas_data['gas_price']),
                    "success"
                )
                
                return {
                    "success": True,
                    "tx_hash": tx_hash_hex,
                    "amount": token_info['balance'],
                    "symbol": token_info['symbol'],
                    "gas_used": receipt.gasUsed,
                    "gas_price": gas_data['gas_price'],
                    "type": "erc20"
                }
                
            except Exception as e:
                error_msg = str(e)
                logging.error(f"ERC-20ËΩ¨Ë¥¶Â§±Ë¥• (ÈáçËØï {retry + 1}/{max_retries}) {token_info['symbol']}: {error_msg}")
                
                # Ê£ÄÊü•ÊòØÂê¶ÊòØ‰ΩôÈ¢ù‰∏çË∂≥ÈîôËØØÔºåÂ¶ÇÊûúÊòØÂàôÁõ¥Êé•Ë∑≥Âá∫ÈáçËØï
                if "insufficient funds" in error_msg.lower() or "‰ΩôÈ¢ù‰∏çË∂≥" in error_msg:
                    translated_error = translate_error_message(error_msg)
                    print_error(f"‚ùå ERC20ËΩ¨Ë¥¶Â§±Ë¥•: {translated_error}")
                    print_warning(f"ÂèñÊ∂àÈáçËØï: ÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù‰∏çË∂≥ÊîØ‰ªògasË¥πÁî®")
                    await self.db_manager.log_transfer(
                        from_address, chain_config['name'], chain_config['chain_id'],
                        f"{token_info['balance']} {token_info['symbol']}", to_address, 
                        status="failed", error_message=error_msg
                    )
                    return {
                        "success": False,
                        "error": error_msg,
                        "type": "erc20",
                        "symbol": token_info['symbol']
                    }
                
                if retry == max_retries - 1:
                    # ËÆ∞ÂΩïÂ§±Ë¥•ÁöÑËΩ¨Ë¥¶
                    await self.db_manager.log_transfer(
                        from_address, chain_config['name'], chain_config['chain_id'],
                        f"{token_info['balance']} {token_info['symbol']}", to_address, 
                        status="failed", error_message=error_msg
                    )
                    
                    return {
                        "success": False,
                        "error": error_msg,
                        "retry_count": max_retries,
                        "type": "erc20",
                        "symbol": token_info['symbol']
                    }
                
                # Á≠âÂæÖ5ÁßíÂêéÈáçËØï
                await asyncio.sleep(5)
        
        return {"success": False, "error": "ËææÂà∞ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞", "type": "erc20"}
    
    async def _send_erc20_gas_shortage_notification(self, from_address: str, token_info: Dict, 
                                                   chain_config: Dict, estimated_gas_cost: int, 
                                                   native_balance: int, token_price: float = None,
                                                   token_value_usd: float = None,
                                                   telegram_bot_token: str = None,
                                                   telegram_chat_id: str = None):
       """ÂèëÈÄÅERC20‰ª£Â∏Ågas‰∏çË∂≥ÁöÑTelegramÈÄöÁü•"""
       try:
           if not telegram_bot_token or not telegram_chat_id:
               return

           # Ê†ºÂºèÂåñ‰ΩôÈ¢ùÊòæÁ§∫
           if token_info['balance'] >= 1:
               balance_str = f"{token_info['balance']:.6f}"
           elif token_info['balance'] >= 0.000001:
               balance_str = f"{token_info['balance']:.8f}"
           else:
               balance_str = f"{token_info['balance']:.12f}"
           
           # ÊûÑÂª∫‰ª∑ÂÄº‰ø°ÊÅØ
           value_info = ""
           if token_price is not None and token_value_usd is not None:
               value_info = (
                   f"üíµ <b>Âçï‰ª∑:</b> ${token_price:.6f}\n"
                   f"üíé <b>ÊÄª‰ª∑ÂÄº:</b> ${token_value_usd:.2f}\n"
               )
           
           message = (
               f"üö® <b>È´ò‰ª∑ÂÄºERC20‰ª£Â∏ÅÂèëÁé∞‰ΩÜGas‰∏çË∂≥</b>\n\n"
               f"üîó <b>Èìæ:</b> {chain_config['name']}\n"
               f"üí∞ <b>‰ª£Â∏Å:</b> {balance_str} {token_info['symbol']}\n"
               f"{value_info}"
               f"üìç <b>ÂêàÁ∫¶Âú∞ÂùÄ:</b> <code>{token_info.get('contract_address', 'N/A')}</code>\n"
               f"üë§ <b>Èí±ÂåÖÂú∞ÂùÄ:</b> <code>{from_address}</code>\n"
               f"‚õΩ <b>ÈúÄË¶ÅGas:</b> {estimated_gas_cost/1e18:.8f} {chain_config['native_token']}\n"
               f"üí≥ <b>ÂΩìÂâç‰ΩôÈ¢ù:</b> {native_balance/1e18:.8f} {chain_config['native_token']}\n"
               f"üìä <b>Áº∫Âè£:</b> {(estimated_gas_cost - native_balance)/1e18:.8f} {chain_config['native_token']}\n\n"
               f"üí° <b>Âª∫ËÆÆÊìç‰Ωú:</b>\n"
               f"1. ÂêëËØ•Âú∞ÂùÄËΩ¨ÂÖ•Ë∂≥Â§üÁöÑ {chain_config['native_token']} ‰Ωú‰∏∫GasË¥π\n"
               f"2. ÊâãÂä®ËΩ¨Âá∫ERC20‰ª£Â∏Å\n"
               f"3. ÊàñÁ≠âÂæÖÁ≥ªÁªüËá™Âä®ÈáçËØï"
           )
           
           # ÂèëÈÄÅÈÄöÁü•
           url = f"https://api.telegram.org/bot{telegram_bot_token}/sendMessage"
           payload = {
               "chat_id": telegram_chat_id,
               "text": message,
               "parse_mode": "HTML"
           }
           
           response = requests.post(url, json=payload, timeout=10)
           response.raise_for_status()
           print_warning(f"üì± Â∑≤ÂèëÈÄÅERC20 Gas‰∏çË∂≥ÈÄöÁü•Âà∞Telegram")
           
       except Exception as e:
           print_error(f"ÂèëÈÄÅERC20 Gas‰∏çË∂≥ÈÄöÁü•Â§±Ë¥•: {e}")
           logging.error(f"ÂèëÈÄÅERC20 Gas‰∏çË∂≥ÈÄöÁü•Â§±Ë¥•: {e}")


class MonitoringApp:
    """‰∏ªÁõëÊéßÂ∫îÁî®Á±ª"""
    
    def __init__(self):
        self.alchemy_api = None
        self.db_manager = DatabaseManager()
        self.transfer_manager = None
        self.price_checker = PriceChecker()  # ‰ª∑Ê†ºÊ£ÄÊü•Âô®
        self.addresses = []
        self.config = {}
        self.monitoring_active = False
        self.blocked_chains_cache = set()  # ÁºìÂ≠òÂ∑≤Â±èËîΩÁöÑÈìæÔºåÈÅøÂÖçÈáçÂ§çÊï∞ÊçÆÂ∫ìÊü•ËØ¢
        self.failed_transfers_cache = set()  # ÁºìÂ≠òÂ§±Ë¥•ÁöÑËΩ¨Ë¥¶ÔºåÈÅøÂÖçÈáçÂ§çÂ∞ùËØï
        self.db_semaphore = asyncio.Semaphore(20)  # Â¢ûÂä†Âπ∂ÂèëÊï∞ÊçÆÂ∫ìÊìç‰ΩúÊï∞ÈáèÔºåÊèêÂçáÈÄüÂ∫¶
        
        # ËΩÆÊ¨°ÁªüËÆ° - ÂàùÂßãÂåñÊâÄÊúâÂøÖË¶ÅÂ±ûÊÄß
        self.round_start_time = time.time()
        self.round_cu_usage = 0
        self.round_count = 0
        
        # ËΩ¨Ë¥¶ÁªüËÆ°
        self.total_transfers = 0
        self.total_value_usd = 0.0
        self.current_round_transfers = 0
        self.current_round_progress = {"current": 0, "total": 0}
        self.chain_progress = {"current": 0, "total": 0}
        self.stats_display_active = False
        self.start_time = time.time()
        
        self.setup_logging()
    
    def setup_logging(self):
        """ËÆæÁΩÆÊó•Âøó"""
        os.makedirs("logs", exist_ok=True)
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('logs/transactions.log', encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
    
    def extract_private_keys(self, private_keys_input: str) -> List[str]:
        """‰ªéËæìÂÖ•ÊñáÊú¨‰∏≠ÊèêÂèñÁßÅÈí•
        ÊîØÊåÅ 0x ÂâçÁºÄ‰∏é‰∏çÂ∏¶ÂâçÁºÄÁöÑ64‰ΩçÂçÅÂÖ≠ËøõÂà∂ÔºåÂéªÈáçÂπ∂È™åËØÅÊúâÊïàÊÄß
        """
        if not private_keys_input or not private_keys_input.strip():
            return []
            
        # Ê∏ÖÁêÜËæìÂÖ•ÔºöÁßªÈô§Â§ö‰ΩôÁ©∫Ê†º„ÄÅÊç¢Ë°åÁ¨¶„ÄÅÂà∂Ë°®Á¨¶
        cleaned_input = re.sub(r'\s+', ' ', private_keys_input.strip())
        
        # ÂêåÊó∂ÂåπÈÖç 0x ÂâçÁºÄÂíåÊó†ÂâçÁºÄÁöÑÁßÅÈí•ÁâáÊÆµ
        private_key_pattern = r'(?:0x)?[a-fA-F0-9]{64}'
        matches = re.findall(private_key_pattern, cleaned_input)

        if not matches:
            logging.warning("Êú™ÊâæÂà∞Á¨¶ÂêàÊ†ºÂºèÁöÑÁßÅÈí•")
            return []

        normalized_keys: List[str] = []
        for key in matches:
            # Áªü‰∏Ä‰∏∫0xÂâçÁºÄÂ∞èÂÜôÊ†ºÂºè
            key_clean = key.lower()
            if not key_clean.startswith('0x'):
                key_clean = '0x' + key_clean
            normalized_keys.append(key_clean)

        # ÂéªÈáç‰∏î‰øùÊåÅÈ°∫Â∫è
        seen = set()
        unique_keys = []
        for key in normalized_keys:
            if key not in seen:
                seen.add(key)
                unique_keys.append(key)

        valid_keys: List[str] = []
        for key in unique_keys:
            try:
                # È™åËØÅÁßÅÈí•ÊúâÊïàÊÄß
                account = Account.from_key(key)
                valid_keys.append(key)
                logging.info(f"ÊèêÂèñÂà∞ÊúâÊïàÁßÅÈí•ÔºåÂØπÂ∫îÂú∞ÂùÄ: {account.address}")
            except Exception as e:
                logging.warning(f"Êó†ÊïàÁßÅÈí• {key[:10]}...: {e}")

        return valid_keys
    
    async def initialize(self):
        """ÂàùÂßãÂåñÂ∫îÁî®"""
        print_progress("ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì...")
        await self.db_manager.init_database()
        
        print_progress("Âä†ËΩΩÈÖçÁΩÆ...")
        await self.load_config()
        
        print_progress("‰ªéÁéØÂ¢ÉÂèòÈáèÂä†ËΩΩÁßÅÈí•...")
        private_keys_str = os.getenv("PRIVATE_KEYS")
        if private_keys_str:
            private_keys = [k.strip() for k in private_keys_str.split(',') if k.strip()]
            self.addresses = []
            for pk in private_keys:
                try:
                    account = Account.from_key(pk)
                    self.addresses.append({'address': account.address, 'private_key': pk})
                except:
                    pass
            if self.addresses:
                print_success(f"‰ªéÁéØÂ¢ÉÂèòÈáèÂä†ËΩΩ‰∫Ü {len(self.addresses)} ‰∏™Âú∞ÂùÄ")
        else:
            print_info("Êú™ÊâæÂà∞PRIVATE_KEYSÁéØÂ¢ÉÂèòÈáèÔºåÈúÄË¶ÅÊâãÂä®ÂØºÂÖ•")
        
        # Á°¨ÁºñÁ†ÅAPIÂØÜÈí•ÈÖçÁΩÆÔºà‰ºòÂÖà‰ΩøÁî®Ôºâ
        hardcoded_api_keys = [
            "olq_SkZ9bg2R6kBMIS2-L",
            "B068RgsZ3lfHLgiYuH36L", 
            "aad36gwoDDP-Sxl8AI4Tu"
        ]
        
        # ‰ºòÂÖà‰ΩøÁî®Á°¨ÁºñÁ†ÅÂØÜÈí•ÔºåÁéØÂ¢ÉÂèòÈáè‰Ωú‰∏∫Â§áÁî®
        env_api_keys = [
            key.strip() 
            for key in os.getenv("ALCHEMY_API_KEYS", "").split(',') 
            if key.strip()
        ]
        
        # ÂêàÂπ∂APIÂØÜÈí•ÔºöÁ°¨ÁºñÁ†Å + ÁéØÂ¢ÉÂèòÈáè
        api_keys = hardcoded_api_keys + env_api_keys
        
        if not api_keys:
            print_error("Êú™ÊâæÂà∞‰ªª‰ΩïAlchemy APIÂØÜÈí•")
            return

        print_info(f"ÈÖçÁΩÆË¥üËΩΩÂùáË°°Âô®Ôºå‰ΩøÁî® {len(api_keys)} ‰∏™APIÂØÜÈí•")
        
        self.alchemy_api = AlchemyAPILoadBalancer(api_keys)
        self.transfer_manager = TransferManager(self.alchemy_api, self.db_manager, self)
        
        # ÊòæÁ§∫‰ª∑Ê†ºÁºìÂ≠òÁªüËÆ°
        cache_stats = self.price_checker.get_cache_stats()
        print_info(f"üíé CoinGecko APIÁä∂ÊÄÅ:")
        print_info(f"   ÊúàÂ∫¶Ë∞ÉÁî®: {cache_stats['monthly_calls']}/10,000")
        print_info(f"   ‰ª∑Ê†ºÁºìÂ≠ò: {cache_stats['valid_cached']} ÊúâÊïà / {cache_stats['total_cached']} ÊÄªËÆ°")
        try:
            cache_hours = (self.price_checker.cache_duration // 3600) if self.price_checker else 24
        except Exception:
            cache_hours = 24
        cache_days = cache_hours / 24
        print_info(f"   ÁºìÂ≠òÊó∂Èïø: {cache_days:g}Â§©")
        
        print_success("ÂàùÂßãÂåñÂÆåÊàê")
    
    async def load_config(self):
        """Âä†ËΩΩÈÖçÁΩÆÊñá‰ª∂"""
        try:
            with open('config.json', 'r', encoding='utf-8') as f:
                self.config = json.load(f)
        except FileNotFoundError:
            # ÂàõÂª∫ÈªòËÆ§ÈÖçÁΩÆ
            self.config = {
                "chains": [
                    {
                        "name": "ETH_MAINNET",
                        "chain_id": 1,
                        "recipient_address": "0x0000000000000000000000000000000000000000",
                        "min_amount": "0"
                    }
                ],
                "erc20": [],
                "settings": {
                    "monitoring_interval": 0.01,
                    "round_pause": 5,
                    "gas_threshold_gwei": 50,
                    "gas_wait_time": 60
                }
            }
            await self.save_config()
    
    async def save_config(self):
        """‰øùÂ≠òÈÖçÁΩÆÊñá‰ª∂"""
        with open('config.json', 'w', encoding='utf-8') as f:
            json.dump(self.config, f, indent=2, ensure_ascii=False)
    
    async def check_chain_history(self, address: str, chain_config: Dict) -> bool:
        """Ê£ÄÊü•ÈìæÊòØÂê¶Êúâ‰∫§ÊòìÂéÜÂè≤"""
        # È¶ñÂÖàÊ£ÄÊü•Êï∞ÊçÆÂ∫ì‰∏≠ÊòØÂê¶Â∑≤ÁªèÂ±èËîΩ
        if await self.db_manager.is_chain_blocked(address, chain_config['chain_id']):
            return False
        
        # Ê£ÄÊü•‰∫§ÊòìÂéÜÂè≤
        has_history, transfer_count = await self.alchemy_api.check_asset_transfers(address, chain_config)
        
        if not has_history:
            # Â±èËîΩÊó†‰∫§ÊòìÂéÜÂè≤ÁöÑÈìæ
            await self.db_manager.block_chain(
                address, chain_config['name'], chain_config['chain_id']
            )
            logging.debug(f"Â±èËîΩÈìæ {chain_config['name']} (Âú∞ÂùÄ: {address}): Êó†‰∫§ÊòìÂéÜÂè≤Êàñ‰∏çÂèØÁî®")
        
        return has_history
    

    
    async def send_telegram_notification(self, message: str):
        """ÂèëÈÄÅTelegramÈÄöÁü•"""
        try:
            url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
            payload = {
                "chat_id": TELEGRAM_CHAT_ID,
                "text": message,
                "parse_mode": "HTML"
            }
            
            response = requests.post(url, json=payload, timeout=10)
            response.raise_for_status()
            print_success("TelegramÈÄöÁü•ÂèëÈÄÅÊàêÂäü")
            
        except Exception as e:
            print_error(f"TelegramÈÄöÁü•ÂèëÈÄÅÂ§±Ë¥•: {e}")
            logging.error(f"TelegramÈÄöÁü•ÂèëÈÄÅÂ§±Ë¥•: {e}")
    
    async def start_monitoring(self):
        """ÂºÄÂßãÁõëÊéß - ÈáçÊûÑÂêéÁöÑÈÄªËæë"""
        # È™åËØÅÂâçÁΩÆÊù°‰ª∂
        if not self.addresses:
            print_error("Ê≤°ÊúâÂèØÁõëÊéßÁöÑÂú∞ÂùÄÔºåËØ∑ÂÖàÂØºÂÖ•ÁßÅÈí•")
            return
        
        if not self.config.get('chains'):
            print_error("Ê≤°ÊúâÈÖçÁΩÆÁõëÊéßÈìæÔºåËØ∑ÈáçÊñ∞ÂØºÂÖ•ÁßÅÈí•")
            return
            
        if not self.alchemy_api:
            print_error("APIÊú™ÂàùÂßãÂåñ")
            return
        
        print_success(f"ÂºÄÂßãÁõëÊéß {len(self.addresses)} ‰∏™Âú∞ÂùÄ")
        print_info("Êåâ Ctrl+C ÂÅúÊ≠¢ÁõëÊéß")
        
        self.monitoring_active = True
        self.stats_display_active = True  # ÂêØÁî®ÁªüËÆ°ÊòæÁ§∫
        
        try:
            # Áõ¥Êé•ÂºÄÂßãÁõëÊéßÂæ™ÁéØ - Ë∑≥ËøáÊâÄÊúâÈ¢ÑÊ£ÄÊü•
            print_progress("üöÄ Âø´ÈÄüÂêØÂä®Ê®°ÂºèÔºöÁõ¥Êé•ÂºÄÂßã‰ΩôÈ¢ùÁõëÊéßÂíåËΩ¨Ë¥¶")
            print_info("‚ö° Ë∑≥ËøáRPCËøûÊé•ÊµãËØïÂíå‰∫§ÊòìËÆ∞ÂΩïÊâ´ÊèèÔºåÁ´ãÂç≥ÂºÄÂßã‰ΩôÈ¢ùÊü•ËØ¢")
            await self.monitoring_loop()
                
        except KeyboardInterrupt:
            print_warning("ÁõëÊéßË¢´Áî®Êà∑‰∏≠Êñ≠")
        except Exception as e:
            print_error(f"ÁõëÊéßËøáÁ®ã‰∏≠Âá∫Èîô: {e}")
            logging.error(f"ÁõëÊéßËøáÁ®ã‰∏≠Âá∫Èîô: {e}")
        finally:
            self.monitoring_active = False
            print_info("ÁõëÊéßÂ∑≤ÂÅúÊ≠¢")
    
    async def initialize_rpc_connections(self):
        """Á¨¨‰∏ÄÊ≠•ÔºöÂàùÂßãÂåñRPCËøûÊé•Âπ∂Â±èËîΩÊó†ÊïàÈìæ"""
        print_chain("üåê ÂàùÂßãÂåñRPCËøûÊé•...")
        
        valid_chains = []
        invalid_chains = []
        
        for chain_setting in self.config['chains']:
            chain_config = None
            for chain_name, supported_config in ChainConfig.SUPPORTED_CHAINS.items():
                if supported_config['chain_id'] == chain_setting['chain_id']:
                    chain_config = supported_config
                    break
            
            if not chain_config:
                invalid_chains.append(chain_setting['name'])
                continue
                
            print_rpc(f"ÊµãËØïËøûÊé•: {chain_config['name']}")
            
            try:
                # ÊµãËØïRPCËøûÊé•
                web3 = self.transfer_manager.get_web3_instance(chain_config)
                if web3.is_connected():
                    valid_chains.append(chain_config['name'])
                    print_success(f"RPCËøûÊé•ÊàêÂäü: {chain_config['name']}")
                else:
                    invalid_chains.append(chain_config['name'])
                    print_error(f"RPCËøûÊé•Â§±Ë¥•: {chain_config['name']}")
            except Exception as e:
                invalid_chains.append(chain_config['name'])
                print_error(f"RPCËøûÊé•ÂºÇÂ∏∏ {chain_config['name']}: {e}")
        
        print_info(f"RPCËøûÊé•ÁªìÊûú: {len(valid_chains)} ÊàêÂäü, {len(invalid_chains)} Â§±Ë¥•")
        if invalid_chains:
            print_warning(f"Êó†ÊïàÈìæ: {', '.join(invalid_chains)}")
    
    async def scan_transaction_history(self):
        """Á¨¨‰∫åÊ≠•ÔºöÊâ´Êèè‰∫§ÊòìËÆ∞ÂΩïÂπ∂Â±èËîΩÊó†‰∫§ÊòìËÆ∞ÂΩïÁöÑÈìæÔºàË∂ÖÈ´òÈÄüÁâàÔºâ"""
        print_chain("üìú Êâ´ÊèèÈìæ‰∏ä‰∫§ÊòìËÆ∞ÂΩï...")
        print_success(f"üöÄ ‰ºòÂåñÊ®°ÂºèÔºöÊØèÊâπ1‰∏™Âú∞ÂùÄÔºåÊØèÊ¨°ÊúÄÂ§ö10Êù°ÈìæÂπ∂ÂèëÊâ´Êèè")
        
        total_scanned = 0
        blocked_count = 0
        
        # ÊâπÈáèÂπ∂ÂèëÂ§ÑÁêÜ - ÊØèÊâπÂ§ÑÁêÜ1‰∏™Âú∞ÂùÄÔºàÈôç‰ΩéÂπ∂ÂèëÂéãÂäõÔºâ
        batch_size = 1
        address_batches = [self.addresses[i:i + batch_size] for i in range(0, len(self.addresses), batch_size)]
        
        for batch_index, address_batch in enumerate(address_batches):
            print_info(f"‚ö° ÊâπÊ¨° {batch_index + 1}/{len(address_batches)}: Âπ∂ÂèëÂ§ÑÁêÜ {len(address_batch)} ‰∏™Âú∞ÂùÄ")
            
            # Âπ∂ÂèëÂ§ÑÁêÜËøô‰∏ÄÊâπÂú∞ÂùÄ
            tasks = []
            for address_info in address_batch:
                task = self.scan_address_chains(address_info, batch_index, len(address_batches))
                tasks.append(task)
            
            # Á≠âÂæÖËøô‰∏ÄÊâπÂÆåÊàê
            batch_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # ÁªüËÆ°ÁªìÊûú
            for result in batch_results:
                if isinstance(result, tuple):
                    scanned, blocked = result
                    total_scanned += scanned
                    blocked_count += blocked
                elif isinstance(result, Exception):
                    print_warning(f"ÊâπÂ§ÑÁêÜÂºÇÂ∏∏: {result}")
        
        print_success(f"üéâ È´òÈÄüÊâ´ÊèèÂÆåÊàê: ÊÄªÊâ´Êèè {total_scanned}, Â±èËîΩ {blocked_count}")
    
    async def scan_address_chains(self, address_info, batch_index, total_batches):
        """Âπ∂ÂèëÊâ´ÊèèÂçï‰∏™Âú∞ÂùÄÁöÑÊâÄÊúâÈìæ"""
        address = address_info['address']
        scanned = 0
        blocked = 0
        
        try:
            print_info(f"üîç ÂºÄÂßãÊâ´ÊèèÂú∞ÂùÄ: {address[:8]}...{address[-6:]}")
            
            # ÈôêÂà∂Âπ∂ÂèëÂ§ÑÁêÜÈìæÊï∞Èáè - ÊØèÊ¨°ÊúÄÂ§ö10Êù°Èìæ
            all_chain_configs = []
            
            for chain_setting in self.config['chains']:
                chain_config = None
                for chain_name, supported_config in ChainConfig.SUPPORTED_CHAINS.items():
                    if supported_config['chain_id'] == chain_setting['chain_id']:
                        chain_config = supported_config
                        break
                
                if chain_config:
                    all_chain_configs.append(chain_config)
            
            print_info(f"üìã Âú∞ÂùÄ {address[:8]}... Â∞ÜÂàÜÊâπÊâ´Êèè {len(all_chain_configs)} Êù°Èìæ")
            
            # ÂàÜÊâπÂ§ÑÁêÜÈìæÔºåÊØèÊâπ10Êù°
            chain_batch_size = 10
            chain_batches = [all_chain_configs[i:i + chain_batch_size] for i in range(0, len(all_chain_configs), chain_batch_size)]
            
            all_chain_results = []
            
            for chain_batch_index, chain_batch in enumerate(chain_batches):
                print_info(f"üîó Êâ´ÊèèÁ¨¨ {chain_batch_index + 1}/{len(chain_batches)} ÊâπÈìæ ({len(chain_batch)} Êù°)")
                
                # Âπ∂ÂèëÂ§ÑÁêÜËøô‰∏ÄÊâπÈìæ
                chain_tasks = []
                for chain_config in chain_batch:
                    task = self.scan_single_chain(address, chain_config)
                    chain_tasks.append(task)
                
                # ‰ΩøÁî®Ë∂ÖÊó∂‰øùÊä§ÔºåÈÅøÂÖçÂç°Ê≠ª
                try:
                    batch_results = await asyncio.wait_for(
                        asyncio.gather(*chain_tasks, return_exceptions=True),
                        timeout=30.0  # 30ÁßíË∂ÖÊó∂
                    )
                    all_chain_results.extend(batch_results)
                except asyncio.TimeoutError:
                    print_error(f"‚è∞ Á¨¨ {chain_batch_index + 1} ÊâπÈìæÊâ´ÊèèË∂ÖÊó∂")
                    # Ë∂ÖÊó∂ÁöÑÈìæÈÉΩÊ†áËÆ∞‰∏∫Â§±Ë¥•
                    timeout_results = [(False, 0, config['name']) for config in chain_batch]
                    all_chain_results.extend(timeout_results)
            
            chain_results = all_chain_results
            valid_chain_configs = all_chain_configs
            
            # ÁªüËÆ°ÁªìÊûú
            valid_chains = 0
            for i, result in enumerate(chain_results):
                if isinstance(result, tuple):
                    has_history, transfer_count, chain_name = result
                    scanned += 1
                    if not has_history:
                        blocked += 1
                    else:
                        valid_chains += 1
                elif isinstance(result, Exception):
                    print_warning(f"ÈìæÊâ´ÊèèÂºÇÂ∏∏ {valid_chain_configs[i]['name']}: {result}")
                    scanned += 1
                    blocked += 1
            
            # ÊòæÁ§∫Âú∞ÂùÄÊâ´ÊèèÁªìÊûú
            if valid_chains > 0:
                print_success(f"‚úÖ {address[:8]}...{address[-6:]}: {valid_chains} ‰∏™ÊúâÊïàÈìæ / {scanned} ÊÄªÈìæ")
            else:
                print_warning(f"‚ö†Ô∏è {address[:8]}...{address[-6:]}: Êó†ÊúâÊïàÈìæ / {scanned} ÊÄªÈìæ")
            
            return scanned, blocked
            
        except Exception as e:
            print_error(f"‚ùå Êâ´ÊèèÂú∞ÂùÄ {address[:8]}... Âá∫Èîô: {e}")
            # ËøîÂõûÈªòËÆ§ÂÄºÔºåÈÅøÂÖçÁ®ãÂ∫èÂ¥©Ê∫É
            return len(self.config.get('chains', [])), len(self.config.get('chains', []))
    
    async def scan_single_chain(self, address, chain_config):
        """Êâ´ÊèèÂçï‰∏™Âú∞ÂùÄÂú®ÂçïÊù°Èìæ‰∏äÁöÑ‰∫§ÊòìÂéÜÂè≤"""
        try:
            # Ê£ÄÊü•ÊòØÂê¶Â∑≤Ë¢´Â±èËîΩ
            cache_key = f"{address}:{chain_config['chain_id']}"
            if cache_key in self.blocked_chains_cache:
                return False, 0, chain_config['name']
            
            # Ê∑ªÂä†Ë∂ÖÊó∂‰øùÊä§ÁöÑAPIË∞ÉÁî®
            try:
                has_history, transfer_count = await asyncio.wait_for(
                    self.alchemy_api.check_asset_transfers(address, chain_config),
                    timeout=30.0  # 30ÁßíË∂ÖÊó∂
                )
                
                if not has_history:
                    # ÂºÇÊ≠•Â±èËîΩÈìæ
                    asyncio.create_task(self.db_manager.block_chain(address, chain_config['name'], chain_config['chain_id']))
                    self.blocked_chains_cache.add(cache_key)
                    return False, 0, chain_config['name']
                else:
                    print_success(f"‚úÖ {chain_config['name']}: ÂèëÁé∞ {transfer_count}+ Êù°ËÆ∞ÂΩï")
                    return True, transfer_count, chain_config['name']
                    
            except asyncio.TimeoutError:
                print_error(f"‚è∞ {chain_config['name']} APIË∞ÉÁî®Ë∂ÖÊó∂")
                # Ë∂ÖÊó∂ÁöÑÈìæ‰πüÊ†áËÆ∞‰∏∫Â±èËîΩÔºåÈÅøÂÖçÈáçÂ§çÂ∞ùËØï
                self.blocked_chains_cache.add(cache_key)
                return False, 0, chain_config['name']
                
        except Exception as e:
            print_error(f"‚ùå Êâ´ÊèèÈìæ {chain_config['name']} ÂºÇÂ∏∏: {e}")
            import traceback
            print_warning(f"ËØ¶ÁªÜÈîôËØØ: {traceback.format_exc()}")
            return False, 0, chain_config['name']
    
    async def monitoring_loop(self):
        """Á¨¨‰∏âÊ≠•ÔºöÁõëÊéßÂæ™ÁéØ"""
        print_chain("üí∞ ÂºÄÂßã‰ΩôÈ¢ùÁõëÊéßÂæ™ÁéØ...")
        
        round_count = 0
        while self.monitoring_active:
            round_count += 1
            self.round_count = round_count
            
            # ÈáçÁΩÆËΩÆÊ¨°ÁªüËÆ°
            import time
            self.round_start_time = time.time()
            # Ëé∑ÂèñÂàùÂßãCU‰ΩøÁî®Èáè
            if isinstance(self.alchemy_api, AlchemyAPILoadBalancer):
                usage_stats = self.alchemy_api.get_usage_stats()
                round_start_cu = usage_stats.get('total_monthly_usage', 0)
            elif self.alchemy_api:
                round_start_cu = getattr(self.alchemy_api, 'current_month_usage', 0)
            else:
                round_start_cu = 0
            self.reset_round_stats()
            
            # ËÆ°ÁÆóÊÄªÊìç‰ΩúÊï∞ÔºàÂú∞ÂùÄÊï∞ * ÈìæÊï∞Ôºâ
            total_operations = len(self.addresses) * len(self.config.get('chains', []))
            self.update_round_progress(0, total_operations)
            
            print_progress(f"Á¨¨ {round_count} ËΩÆÁõëÊéßÂºÄÂßã")
            
            # ‰∏∫ÊØè‰∏™Âú∞ÂùÄÂçïÁã¨Â§ÑÁêÜÔºåÊèê‰æõÊõ¥Ê∏ÖÊô∞ÁöÑÊòæÁ§∫
            total_transfers_this_round = 0
            for addr_index, address_info in enumerate(self.addresses, 1):
                address = address_info['address']
                print(f"\n{Fore.CYAN}üìç Âú∞ÂùÄ {addr_index}/{len(self.addresses)}: {address[:8]}...{address[-6:]}{Style.RESET_ALL}")
                
                # Â§ÑÁêÜËØ•Âú∞ÂùÄÁöÑÊâÄÊúâÈìæ
                address_transfers = 0
                for chain_setting in self.config['chains']:
                    # ÈÄöËøáchain_idÊü•ÊâæÈÖçÁΩÆÔºåÊõ¥ÂèØÈù†
                    chain_config = None
                    for chain_name, supported_config in ChainConfig.SUPPORTED_CHAINS.items():
                        if supported_config['chain_id'] == chain_setting['chain_id']:
                            chain_config = supported_config
                            break
                    
                    if chain_config:
                        result = await self.check_and_transfer(address_info, chain_config)
                        if result:
                            address_transfers += 1
                            total_transfers_this_round += 1
                
                # ÊòæÁ§∫ËØ•Âú∞ÂùÄÁöÑÁªìÊûú
                if address_transfers > 0:
                    print(f"{Fore.GREEN}‚úÖ Âú∞ÂùÄ {addr_index}: {address_transfers} Á¨îËΩ¨Ë¥¶{Style.RESET_ALL}")
                else:
                    print(f"{Fore.YELLOW}‚≠ï Âú∞ÂùÄ {addr_index}: Êó†ËΩ¨Ë¥¶{Style.RESET_ALL}")
            
            transfer_count = total_transfers_this_round

            # ËÆ°ÁÆóÊú¨ËΩÆCUÊ∂àËÄó
            if isinstance(self.alchemy_api, AlchemyAPILoadBalancer):
                usage_stats = self.alchemy_api.get_usage_stats()
                round_end_cu = usage_stats.get('total_monthly_usage', 0)
            elif self.alchemy_api:
                round_end_cu = getattr(self.alchemy_api, 'current_month_usage', 0)
            else:
                round_end_cu = 0
            self.round_cu_usage = round_end_cu - round_start_cu
            
            print_success(f"Á¨¨ {round_count} ËΩÆÂÆåÊàêÔºåÊâßË°å {transfer_count} Á¨îËΩ¨Ë¥¶")
            
            # ÊØè10ËΩÆÊ∏ÖÁêÜ‰∏ÄÊ¨°Â§±Ë¥•ËΩ¨Ë¥¶ÁºìÂ≠òÔºåÈÅøÂÖçÁºìÂ≠òËøáÂ§ß
            if round_count % 10 == 0 and len(self.failed_transfers_cache) > 0:
                print_info(f"üßπ Ê∏ÖÁêÜÂ§±Ë¥•ËΩ¨Ë¥¶ÁºìÂ≠ò: {len(self.failed_transfers_cache)} Êù°ËÆ∞ÂΩï")
                self.failed_transfers_cache.clear()
            
            # ÊòæÁ§∫API‰ΩøÁî®ÁªüËÆ°
            if self.alchemy_api:
                try:
                    usage_stats = self.alchemy_api.get_usage_stats()
                    print_info(f"üìä API‰ΩøÁî®ÁªüËÆ°:")
                    print_info(f"   ÂΩìÂâçÈÄüÁéá: {usage_stats.get('current_cu_rate', 0)} CU/s")
                    print_info(f"   Êú¨ËΩÆÊ∂àËÄó: {self.round_cu_usage:,} CU")
                    print_info(f"   ÊúàÂ∫¶‰ΩøÁî®: {usage_stats.get('monthly_usage', 0):,} / {usage_stats.get('monthly_limit', 0):,} CU ({usage_stats.get('usage_percentage', 0):.1f}%)")
                    print_info(f"   ÊØèÊó•È¢ÑÁÆó: {usage_stats.get('daily_budget', 0):,} CU")
                    print_info(f"   Ââ©‰ΩôÂ§©Êï∞: {usage_stats.get('days_remaining', 0)} Â§©")
                except Exception as e:
                    print_warning(f"Ëé∑ÂèñAPIÁªüËÆ°Â§±Ë¥•: {e}")
            
            # Âä®ÊÄÅËÆ°ÁÆóÊöÇÂÅúÊó∂Èó¥ÔºàÂØπ‰∫éË¥üËΩΩÂùáË°°Âô®ÂáèÂ∞ëÊöÇÂÅúÊó∂Èó¥Ôºâ
            try:
                if isinstance(self.alchemy_api, AlchemyAPILoadBalancer):
                    # Â§öAPIÊÉÖÂÜµ‰∏ãÂáèÂ∞ëÊöÇÂÅúÊó∂Èó¥
                    dynamic_pause = max(2, self.calculate_dynamic_pause() // 3)
                else:
                    dynamic_pause = self.calculate_dynamic_pause()
            except Exception as e:
                print_warning(f"ËÆ°ÁÆóÂä®ÊÄÅÊöÇÂÅúÊó∂Èó¥Âá∫Èîô: {e}Ôºå‰ΩøÁî®ÈªòËÆ§ÂÄº")
                dynamic_pause = 5  # ÈªòËÆ§ÊöÇÂÅú5Áßí
            
            print_info(f"‚è±Ô∏è Êô∫ËÉΩÊöÇÂÅú {dynamic_pause} Áßí...")
            await asyncio.sleep(dynamic_pause)
    
    async def check_and_transfer_with_progress(self, address_info: Dict, chain_config: Dict, 
                                             current_operation: int, total_operations: int) -> bool:
        """Ê£ÄÊü•Âçï‰∏™Âú∞ÂùÄÂíåÈìæÁöÑ‰ΩôÈ¢ùÂπ∂ÊâßË°åËΩ¨Ë¥¶ÔºàÂ∏¶ËøõÂ∫¶Êõ¥Êñ∞Ôºâ"""
        self.update_round_progress(current_operation + 1, total_operations)
        return await self.check_and_transfer(address_info, chain_config)
    
    async def check_and_transfer(self, address_info: Dict, chain_config: Dict) -> bool:
        """Ê£ÄÊü•Âçï‰∏™Âú∞ÂùÄÂíåÈìæÁöÑ‰ΩôÈ¢ùÂπ∂ÊâßË°åËΩ¨Ë¥¶"""
        address = address_info['address']
        chain_name = chain_config['name']
        
        try:
            all_balances = await self.alchemy_api.get_all_token_balances(address, chain_config)
            
            # Ê£ÄÊü•ÊòØÂê¶Êúâ‰ΩôÈ¢ù
            has_balance = False
            total_tokens = 0
            
            if all_balances:
                for token_key, token_info in all_balances.items():
                    total_tokens += 1
                    if token_info['balance'] > 0:
                        has_balance = True
                        
                        # ÁîüÊàêÂ§±Ë¥•ËΩ¨Ë¥¶ÁºìÂ≠òÈîÆ
                        cache_key = f"{address}:{chain_config['chain_id']}:{token_info.get('symbol', 'UNKNOWN')}:{token_info.get('type', 'unknown')}"
                        
                        # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ§±Ë¥•ËøáÔºåÈÅøÂÖçÈáçÂ§çÂ∞ùËØïÁõ∏ÂêåÁöÑÊó†ÊïàËΩ¨Ë¥¶
                        if cache_key in self.failed_transfers_cache:
                            print(f"{Fore.YELLOW}‚ö†Ô∏è Ë∑≥ËøáÂ∑≤Áü•Â§±Ë¥•ËΩ¨Ë¥¶: {token_info['symbol']} ({chain_name}){Style.RESET_ALL}")
                            continue
                        
                        # ÂèñÊ∂àÊúÄÂ∞èÈ¢ùÂ∫¶ÈòàÂÄºÈôêÂà∂Ôºå‰ªª‰ΩïÂ§ß‰∫é0ÁöÑ‰ΩôÈ¢ùÈÉΩËøõË°åËΩ¨Ë¥¶
                        balance = token_info['balance']
                        balance_str = f"{balance:.6f}" if balance >= 1 else f"{balance:.12f}"
                        
                        # üéØ Á≤âÂ∞òÈáëÈ¢ùÁâπÊÆäÊ†áËØÜ
                        if token_info.get('type') == 'native' and balance <= 0.001:
                            print(f"{Fore.YELLOW}üí® ÂèëÁé∞Á≤âÂ∞ò‰ΩôÈ¢ù: {balance_str} {token_info['symbol']} ({chain_name}) - ÂêØÁî®Ë∂Ö‰ΩégasÊ®°Âºè{Style.RESET_ALL}")
                        else:
                            print(f"{Fore.RED}üî¥ ÂèëÁé∞‰ΩôÈ¢ù: {balance_str} {token_info['symbol']} ({chain_name}){Style.RESET_ALL}")
                        
                        result = await self.execute_transfer(address_info, chain_config, token_info)
                        
                        # Â¶ÇÊûúËΩ¨Ë¥¶Â§±Ë¥•ÔºåÊ∑ªÂä†Âà∞Â§±Ë¥•ÁºìÂ≠ò‰∏≠
                        if result and not result.get('success'):
                            error_msg = result.get('error', '')
                            # ÁºìÂ≠òÂ§öÁßçÁ±ªÂûãÁöÑÂ§±Ë¥•ÔºåÈÅøÂÖçÈáçÂ§çÂ∞ùËØï
                            cache_conditions = [
                                "‰ΩôÈ¢ù‰∏çË∂≥" in error_msg,
                                "insufficient funds" in error_msg.lower(),
                                "max fee per gas less than block base fee" in error_msg.lower(),
                                "ÈáëÈ¢ùËøáÂ∞èÔºåË∑≥ËøáËΩ¨Ë¥¶Â∞ùËØï" in error_msg
                            ]
                            
                            if any(cache_conditions):
                                self.failed_transfers_cache.add(cache_key)
                                print(f"{Fore.GRAY}üìù Â∑≤ÁºìÂ≠òÂ§±Ë¥•ËΩ¨Ë¥¶: {token_info['symbol']} ({chain_name}){Style.RESET_ALL}")
                        if result and result.get('success'):
                            transfer_value_usd = 0.0
                            try:
                                token_price = await self.price_checker.get_token_price_usd(
                                    token_info['symbol'],
                                    token_info.get('contract_address')
                                )
                                if token_price:
                                    transfer_value_usd = (result.get('amount', 0) or 0) * token_price
                            except Exception as e:
                                logging.debug(f"ËÆ°ÁÆóËΩ¨Ë¥¶‰ª∑ÂÄºÂ§±Ë¥•: {e}")
                            
                            self.add_transfer_stats(transfer_value_usd)
                            print_transfer(f"ËΩ¨Ë¥¶ÊàêÂäü: {result.get('amount', 0)} {token_info['symbol']} (${transfer_value_usd:.2f})")
            
            # ÊòæÁ§∫ÈìæÁä∂ÊÄÅ
            if not has_balance:
                print(f"{Fore.BLACK}‚ö´ Êó†‰ΩôÈ¢ù: {chain_name}{Style.RESET_ALL}")
            
            return has_balance
            
        except Exception as e:
            # ÂØπ‰∫éAPIÈîôËØØÔºå‰πüÊòæÁ§∫‰∏∫Êó†‰ΩôÈ¢ùÁä∂ÊÄÅ
            print(f"{Fore.BLACK}‚ö´ Êó†‰ΩôÈ¢ù: {chain_name} (APIÈîôËØØ){Style.RESET_ALL}")
            return False
    
    async def execute_transfer(self, address_info: Dict, chain_config: Dict, token_info: Dict) -> Dict:
        """ÊâßË°åËΩ¨Ë¥¶Êìç‰Ωú"""
        address = address_info['address']
        private_key = address_info['private_key']
        # ‰ºòÂÖà‰ΩøÁî®ÈìæÁ∫ßÈÖçÁΩÆ‰∏≠ÁöÑÊî∂Ê¨æÂú∞ÂùÄÔºåÂõûÈÄÄÂà∞ÂÖ®Â±ÄTARGET_ADDRESS
        recipient = None
        try:
            recipient = next((c.get('recipient_address') for c in self.config.get('chains', []) if c.get('chain_id') == chain_config.get('chain_id') and c.get('recipient_address')), None)
        except Exception:
            recipient = None
        recipient = recipient or TARGET_ADDRESS
        
        token_type = token_info['type']
        symbol = token_info['symbol']
        balance = token_info['balance']
        
        # ‰ΩøÁî®‰∏éÂèëÁé∞‰ΩôÈ¢ùÁõ∏ÂêåÁöÑÊ†ºÂºèÂåñÈÄªËæë
        if balance >= 1:
            balance_str = f"{balance:.6f}"
        elif balance >= 0.000001:
            balance_str = f"{balance:.8f}"
        else:
            balance_str = f"{balance:.12f}"
        
        print_transfer(f"üí∏ ÂáÜÂ§áËΩ¨Ë¥¶: {balance_str} {symbol} -> {recipient}")
        
        try:
            if token_type == 'native':
                # ÂéüÁîü‰ª£Â∏ÅËΩ¨Ë¥¶
                result = await self.transfer_manager.send_native_transaction(
                    private_key, address, recipient, balance, chain_config
                )
            elif token_type == 'erc20':
                # ERC-20‰ª£Â∏ÅËΩ¨Ë¥¶
                result = await self.transfer_manager.send_erc20_transaction(
                    private_key, address, recipient, token_info, chain_config
                )
            else:
                print_warning(f"‰∏çÊîØÊåÅÁöÑ‰ª£Â∏ÅÁ±ªÂûã: {token_type}")
                return None
            
            if result['success']:
                print_success(f"{token_type.upper()}ËΩ¨Ë¥¶ÊàêÂäü: {result['amount']} {symbol}")
                print_info(f"‰∫§ÊòìÂìàÂ∏å: {result['tx_hash']}")
                
                # ÂèëÈÄÅTelegramÈÄöÁü•
                await self.send_telegram_notification(
                    f"<b>‚úÖ {token_type.upper()}ËΩ¨Ë¥¶ÊàêÂäü</b>\n"
                    f"üîó Èìæ: {chain_config['name']}\n"
                    f"üí∞ ‰ª£Â∏Å: {symbol}\n"
                    f"üìä Êï∞Èáè: {balance}\n"
                    f"üì§ ‰ªé: <code>{address}</code>\n"
                    f"üì• Âà∞: <code>{recipient}</code>\n"
                    f"üîç ‰∫§Êòì: <code>{result['tx_hash']}</code>"
                )
            else:
                print_error(f"{token_type.upper()}ËΩ¨Ë¥¶Â§±Ë¥•: {result['error']}")
                
            return result
            
        except Exception as e:
            print_error(f"ËΩ¨Ë¥¶ÂºÇÂ∏∏: {e}")
            return {"success": False, "error": str(e)}
    
    def stop_monitoring(self):
        """ÂÅúÊ≠¢ÁõëÊéß"""
        self.monitoring_active = False
    

    
    async def configure_private_keys(self):
        """ÂØºÂÖ•ÁßÅÈí•"""
        print_chain("üì• ÂØºÂÖ•ÁßÅÈí•")
        print_error("ÂÆâÂÖ®Ë≠¶Âëä: ‰ª•Á∫ØÊñáÊú¨Ê†ºÂºèÂ≠òÂÇ®ÁßÅÈí•Â≠òÂú®È£éÈô©„ÄÇËØ∑Á°Æ‰øùÊÇ®ÁöÑÁéØÂ¢ÉÂÆâÂÖ®„ÄÇ")
        print_info("ÊîØÊåÅÊ†ºÂºè:")
        print_info("- Âçï‰∏™ÁßÅÈí•: 0xabc123...def789")
        print_info("- Â§ö‰∏™ÁßÅÈí•: 0xabc123...def789,0x123...456")
        print_info("- ÊØèË°å‰∏Ä‰∏™ÁßÅÈí•ÔºàÊîØÊåÅÂ§öË°åÁ≤òË¥¥Ôºâ")
        print_info("- ËæìÂÖ• 'end' ÁªìÊùüËæìÂÖ•ÔºàÂå∫ÂàÜÂ§ßÂ∞èÂÜôÔºâ")
        print_warning("‚ö†Ô∏è  Ê≥®ÊÑèÔºöÂè™ÊúâËæìÂÖ• 'end' ÊâçËÉΩÁªìÊùüÔºå‰∏çÊîØÊåÅÂèåÂáªÂõûËΩ¶ÁªìÊùü")

        # ÊîØÊåÅËøûÁª≠Â§öË°åËæìÂÖ•ÔºåÁõ¥Âà∞ËæìÂÖ• 'end' ‰∏∫Ê≠¢
        lines = []
        print_progress("ËØ∑ËæìÂÖ•ÁßÅÈí•ÂÜÖÂÆπÔºàËæìÂÖ• 'end' ÁªìÊùüÔºâ:")
        
        try:
            line_count = 0
            while True:
                try:
                    line = input(f"Á¨¨{line_count + 1}Ë°å> ").strip()
                except EOFError:
                    print_info("Ê£ÄÊµãÂà∞EOFÔºåÁªßÁª≠Á≠âÂæÖËæìÂÖ•...")
                    continue
                
                # Âè™ÊúâËæìÂÖ• 'end' ÊâçÁªìÊùü
                if line == 'end':
                    print_success("Ê£ÄÊµãÂà∞ÁªìÊùüÊ†áËÆ∞ 'end'ÔºåÂºÄÂßãÂ§ÑÁêÜËæìÂÖ•...")
                    break
                
                # Âç≥‰ΩøÊòØÁ©∫Ë°å‰πüÊ∑ªÂä†Âà∞lines‰∏≠Ôºå‰∏ç‰ºöÁªìÊùüËæìÂÖ•
                lines.append(line)
                line_count += 1
                
                # ÊòæÁ§∫ÂΩìÂâçÂ∑≤ËæìÂÖ•ÁöÑË°åÊï∞
                if line_count % 5 == 0:
                    print_info(f"Â∑≤ËæìÂÖ• {line_count} Ë°åÔºåËæìÂÖ• 'end' ÁªìÊùü")
                    
        except KeyboardInterrupt:
            print_warning("ËæìÂÖ•Ë¢´‰∏≠Êñ≠")
            return
        except Exception as e:
            print_error(f"ËæìÂÖ•ÈîôËØØ: {e}")
            return

        private_keys_input = ' '.join(lines)

        if private_keys_input and private_keys_input.strip():
            private_keys = self.extract_private_keys(private_keys_input)
            if private_keys:
                print_success(f"ÊèêÂèñÂà∞ {len(private_keys)} ‰∏™ÊúâÊïàÁßÅÈí•")

                # ÊòæÁ§∫ÂØπÂ∫îÁöÑÂú∞ÂùÄ
                print_info("ÂØπÂ∫îÂú∞ÂùÄ:")
                for i, private_key in enumerate(private_keys):
                    try:
                        account = Account.from_key(private_key)
                        print_balance(f"{i+1}. {account.address}")
                    except Exception as e:
                        print_error(f"{i+1}. ÈîôËØØ: {e}")

                print_info(f"ËΩ¨Ë¥¶ÁõÆÊ†áÂú∞ÂùÄ: {TARGET_ADDRESS}")

                try:
                    # Â∞ÜÁßÅÈí•ÂÜôÂÖ•.env
                    joined_keys = ",".join(private_keys)
                    # APIÂØÜÈí•Â∑≤Á°¨ÁºñÁ†ÅÂà∞Á®ãÂ∫è‰∏≠ÔºåÊó†ÈúÄÊâãÂä®ÈÖçÁΩÆ.envÊñá‰ª∂
                    print_success("‚úÖ APIÂØÜÈí•Â∑≤ÂÜÖÁΩÆÂà∞Á®ãÂ∫è‰∏≠ÔºåÊó†ÈúÄÈ¢ùÂ§ñÈÖçÁΩÆ")
                    print_info("üí° Â¶ÇÈúÄ‰ΩøÁî®ÂÖ∂‰ªñAPIÂØÜÈí•ÔºåÂèØÂú®.envÊñá‰ª∂‰∏≠ÈÖçÁΩÆALCHEMY_API_KEYS")
                    print_warning("‚ö†Ô∏è  Ê≥®ÊÑèÔºöÂ≠òÂÇ®ÊòéÊñáÁßÅÈí•Â≠òÂú®ÂÆâÂÖ®È£éÈô©ÔºåËØ∑Á°Æ‰øùÁéØÂ¢ÉÂÆâÂÖ®")

                    # ÈáçÊñ∞ÂàùÂßãÂåñÂú∞ÂùÄÂàóË°®
                    self.addresses = []
                    for private_key in private_keys:
                        try:
                            account = Account.from_key(private_key)
                            self.addresses.append({
                                'address': account.address,
                                'private_key': private_key
                            })
                        except Exception as e:
                            logging.error(f"Â§ÑÁêÜÁßÅÈí•Â§±Ë¥•: {e}")

                    # ÂàõÂª∫ÈÖçÁΩÆ - Âè™ÁõëÊéßopBNBÈìæ
                    working_chains = [
                        "OPBNB"  # Âè™‰øùÁïôopBNBÈìæ
                    ]
                    
                    chains_config = []
                    for chain_name in working_chains:
                        if chain_name in ChainConfig.SUPPORTED_CHAINS:
                            chain_info = ChainConfig.SUPPORTED_CHAINS[chain_name]
                            chains_config.append({
                                "name": chain_name,
                                "chain_id": chain_info['chain_id'],
                                "recipient_address": TARGET_ADDRESS,
                                "min_amount": "0.0000005"  # Ë∂Ö‰ΩéÈó®ÊßõÔºåÊ®°‰ªøOKXÁ≠ñÁï•ÔºåÁ°Æ‰øù0.01ÁæéÈáëÈÉΩËÉΩËΩ¨Âá∫
                            })

                    self.config = {
                        "chains": chains_config,
                        "erc20": [],
                        "settings": {
                            "monitoring_interval": 1.0,  # ËÆæÁΩÆÊõ¥ÂêàÁêÜÁöÑÈó¥Èöî
                            "round_pause": 5,
                            "gas_threshold_gwei": 50,
                            "gas_wait_time": 60,
                            "adaptive_timing": True  # ÂêØÁî®Ëá™ÈÄÇÂ∫îÊó∂Èó¥Ë∞ÉÊï¥
                        }
                    }
                    await self.save_config()

                    print_success("ÁßÅÈí•ÂØºÂÖ•ÂÆåÊàêÔºÅ")
                    print_success(f"Â∑≤ÈÖçÁΩÆ {len(self.addresses)} ‰∏™Âú∞ÂùÄÁõëÊéß")
                    print_success(f"Â∑≤ÈÖçÁΩÆ {len(chains_config)} Êù°ÈìæÁõëÊéß")
                    print_success(f"ÁõÆÊ†áÂú∞ÂùÄ: {TARGET_ADDRESS}")
                    
                except Exception as e:
                    print_error(f"‰øùÂ≠òÈÖçÁΩÆÂ§±Ë¥•: {e}")
                    logging.error(f"‰øùÂ≠òÈÖçÁΩÆÂ§±Ë¥•: {e}")
            else:
                print_error("Êú™ÊâæÂà∞ÊúâÊïàÁßÅÈí•ÔºåËØ∑Ê£ÄÊü•ËæìÂÖ•Ê†ºÂºè")
        else:
            print_error("Êú™ËæìÂÖ•‰ªª‰ΩïÂÜÖÂÆπ")
    
    def print_stats_header(self):
        """ÊâìÂç∞ÁªüËÆ°‰ø°ÊÅØÂ§¥ÈÉ®"""
        if not self.stats_display_active:
            return
            
        # ËÆ°ÁÆóËøêË°åÊó∂Èó¥
        running_time = time.time() - self.start_time
        hours = int(running_time // 3600)
        minutes = int((running_time % 3600) // 60)
        seconds = int(running_time % 60)
        
        # Ëé∑ÂèñAPI‰ΩøÁî®ÁªüËÆ°
        usage_stats = self.get_normalized_usage_stats()
        cache_stats = self.price_checker.get_cache_stats() if self.price_checker else {}
        
        # Ê†ºÂºèÂåñÁªüËÆ°‰ø°ÊÅØ
        stats_lines = [
            f"üöÄ EVMÂ§öÈìæÁõëÊéßÂ∑•ÂÖ∑ - ÂÆûÊó∂ÁªüËÆ°",
            f"‚è∞ ËøêË°åÊó∂Èó¥: {hours:02d}:{minutes:02d}:{seconds:02d}",
            f"üîÑ ÁõëÊéßËΩÆÊ¨°: {self.round_count}",
            f"üí∏ ÊÄªËΩ¨Ë¥¶Êï∞: {self.total_transfers} Á¨î",
            f"üí∞ ÊÄª‰ª∑ÂÄº: ${self.total_value_usd:.2f}",
            f"üìä Êú¨ËΩÆËøõÂ∫¶: {self.current_round_progress['current']}/{self.current_round_progress['total']}",
            f"üîó ÈìæËøõÂ∫¶: {self.chain_progress['current']}/{self.chain_progress['total']}",
            f"‚ö° Alchemy: {usage_stats.get('total_cu_rate', 0)}/1500 CU/s ({usage_stats.get('usage_percentage', 0):.1f}%)",
            f"üíé CoinGecko: {cache_stats.get('monthly_calls', 0)}/10,000 ({cache_stats.get('minute_calls', 0)}/30/min)",
            f"üè™ ‰ª∑Ê†ºÁºìÂ≠ò: {cache_stats.get('valid_cached', 0)} ÊúâÊïà / {cache_stats.get('total_cached', 0)} ÊÄªËÆ°",
        ]
        
        # ÁÆÄÂåñÊòæÁ§∫ÔºàÂú®ÁªàÁ´ØÈ°∂ÈÉ®ÊòæÁ§∫‰∏ÄË°åÁªüËÆ°Ôºâ
        api_status_summary = "/".join([f"API{api['api_index']}:{api['current_cu_rate']}" for api in usage_stats.get('api_details', [])])
        stats_summary = (f"üöÄ ËΩÆÊ¨°:{self.round_count} | üí∏ ËΩ¨Ë¥¶:{self.total_transfers}Á¨î | "
                        f"üí∞ ${self.total_value_usd:.2f} | üìä {self.current_round_progress['current']}/{self.current_round_progress['total']} | "
                        f"üîó {self.chain_progress['current']}/{self.chain_progress['total']} | "
                        f"‚ö° {usage_stats.get('total_cu_rate', 0)}/1500 CU/s | "
                        f"üîß {api_status_summary} | "
                        f"üìà {usage_stats.get('usage_percentage', 0):.1f}%")
        
        # ‰ΩøÁî®ANSIËΩ¨‰πâÂ∫èÂàóÂú®ÁªàÁ´ØÊ†áÈ¢òÊ†èÊòæÁ§∫
        print(f"\033]0;{stats_summary}\007", end="")
        
        # ÂêåÊó∂Âú®ÊØèËΩÆÂºÄÂßãÊó∂ÊòæÁ§∫ËØ¶ÁªÜÁªüËÆ°
        if self.current_round_progress['current'] == 0:
            print(f"{Fore.CYAN}{'='*80}{Style.RESET_ALL}")
            print(f"{Fore.WHITE}{Back.BLUE} üìä ÂÆûÊó∂ÁªüËÆ°ÊÄªËßà {Style.RESET_ALL}")
            print(f"{Fore.CYAN}{'='*80}{Style.RESET_ALL}")
            for line in stats_lines:
                print(f"{Fore.YELLOW}{line}{Style.RESET_ALL}")
            print(f"{Fore.CYAN}{'='*80}{Style.RESET_ALL}")
    
    def update_round_progress(self, current: int, total: int):
        """Êõ¥Êñ∞ËΩÆÊ¨°ËøõÂ∫¶"""
        self.current_round_progress = {"current": current, "total": total}
        if self.stats_display_active:
            self.print_stats_header()
    
    def update_chain_progress(self, current: int, total: int):
        """Êõ¥Êñ∞ÈìæËøõÂ∫¶"""
        self.chain_progress = {"current": current, "total": total}
        if self.stats_display_active:
            self.print_stats_header()
    
    def add_transfer_stats(self, value_usd: float = 0.0):
        """Ê∑ªÂä†ËΩ¨Ë¥¶ÁªüËÆ°"""
        self.total_transfers += 1
        self.current_round_transfers += 1
        self.total_value_usd += value_usd
        if self.stats_display_active:
            self.print_stats_header()
    
    def reset_round_stats(self):
        """ÈáçÁΩÆËΩÆÊ¨°ÁªüËÆ°"""
        self.current_round_transfers = 0
        self.current_round_progress = {"current": 0, "total": 0}
        self.chain_progress = {"current": 0, "total": 0}
    
    def get_normalized_usage_stats(self) -> Dict:
        """Ëé∑ÂèñÁªü‰∏ÄÂåñÁöÑAPI‰ΩøÁî®ÁªüËÆ°‰ø°ÊÅØ"""
        if not self.alchemy_api:
            return {
                "current_cu_rate": 0,
                "total_cu_rate": 0,
                "monthly_usage": 0,
                "total_monthly_usage": 0,
                "monthly_limit": 30_000_000,
                "total_monthly_limit": 30_000_000,
                "monthly_remaining": 30_000_000,
                "usage_percentage": 0,
                "daily_budget": 1_000_000,
                "days_remaining": 15,
                "api_details": []
            }
        
        usage_stats = self.alchemy_api.get_usage_stats()
        
        # ÈÄÇÈÖçË¥üËΩΩÂùáË°°Âô®ÁöÑÁªüËÆ°ÁªìÊûÑ
        if isinstance(self.alchemy_api, AlchemyAPILoadBalancer):
            # Ë¥üËΩΩÂùáË°°Âô®ËøîÂõûÁöÑÁªüËÆ°ÁªìÊûÑ
            return {
                "current_cu_rate": usage_stats.get("total_cu_rate", 0),
                "total_cu_rate": usage_stats.get("total_cu_rate", 0),
                "monthly_usage": usage_stats.get("total_monthly_usage", 0),
                "total_monthly_usage": usage_stats.get("total_monthly_usage", 0),
                "monthly_limit": usage_stats.get("total_monthly_limit", 90_000_000),
                "total_monthly_limit": usage_stats.get("total_monthly_limit", 90_000_000),
                "monthly_remaining": usage_stats.get("total_monthly_limit", 90_000_000) - usage_stats.get("total_monthly_usage", 0),
                "usage_percentage": usage_stats.get("usage_percentage", 0),
                "daily_budget": (usage_stats.get("total_monthly_limit", 90_000_000) - usage_stats.get("total_monthly_usage", 0)) // 15,
                "days_remaining": 15,
                "api_details": usage_stats.get("api_details", [])
            }
        else:
            # Âçï‰∏™APIÁöÑÁªüËÆ°ÁªìÊûÑ
            return {
                "current_cu_rate": usage_stats.get("current_cu_rate", 0),
                "total_cu_rate": usage_stats.get("current_cu_rate", 0),
                "monthly_usage": usage_stats.get("monthly_usage", 0),
                "total_monthly_usage": usage_stats.get("monthly_usage", 0),
                "monthly_limit": usage_stats.get("monthly_limit", 30_000_000),
                "total_monthly_limit": usage_stats.get("monthly_limit", 30_000_000),
                "monthly_remaining": usage_stats.get("monthly_remaining", 30_000_000),
                "usage_percentage": usage_stats.get("usage_percentage", 0),
                "daily_budget": usage_stats.get("daily_budget", 1_000_000),
                "days_remaining": usage_stats.get("days_remaining", 15),
                "api_details": [{
                    "api_index": 1,
                    "api_key_preview": "Single API",
                    "current_cu_rate": usage_stats.get("current_cu_rate", 0),
                    "monthly_usage": usage_stats.get("monthly_usage", 0),
                    "monthly_limit": usage_stats.get("monthly_limit", 30_000_000),
                    "usage_percentage": usage_stats.get("usage_percentage", 0),
                    "available": True
                }]
            }
    
    def calculate_dynamic_pause(self) -> int:
        """Ê†πÊçÆÊúàÂ∫¶È¢ùÂ∫¶‰ΩøÁî®ÊÉÖÂÜµËÆ°ÁÆóÂä®ÊÄÅÊöÇÂÅúÊó∂Èó¥"""
        if not self.alchemy_api:
            return 5  # ÈªòËÆ§5Áßí
            
        normalized_stats = self.get_normalized_usage_stats()
        
        # ‰ΩøÁî®Áªü‰∏ÄÂåñÁöÑÁªüËÆ°‰ø°ÊÅØ
        monthly_remaining = normalized_stats["monthly_remaining"]
        days_remaining = normalized_stats["days_remaining"]
        daily_budget = normalized_stats["daily_budget"]
        
        if days_remaining <= 0 or daily_budget <= 0:
            return 300  # Â¶ÇÊûúÈ¢ùÂ∫¶Áî®Â∞ΩÔºåÊöÇÂÅú5ÂàÜÈíü
        
        # ÂàùÂßãÂåñËΩÆÊ¨°ÁªüËÆ°Â±ûÊÄßÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
        if not hasattr(self, 'round_cu_usage'):
            self.round_cu_usage = 0
        if not hasattr(self, 'round_start_time'):
            self.round_start_time = time.time()
        
        # Â¶ÇÊûúËøô‰∏ÄËΩÆÊ∂àËÄó‰∫ÜCUÔºåËÆ°ÁÆóÂª∫ËÆÆÁöÑÊöÇÂÅúÊó∂Èó¥
        if self.round_cu_usage > 0 and self.round_start_time:
            round_duration = time.time() - self.round_start_time
            
            # ËÆ°ÁÆóÊØèÁßíCUÊ∂àËÄóÁéá
            cu_per_second = self.round_cu_usage / max(round_duration, 1)
            
            # ËÆ°ÁÆóÊØèÊó•CUÂàÜÈÖç‰∏ãÔºåÂâ©‰ΩôÊó∂Èó¥ÂèØ‰ª•ËøêË°åÁöÑÁßíÊï∞
            if cu_per_second > 0:
                daily_runtime_seconds = daily_budget / cu_per_second
                
                # ‰∏ÄÂ§©Êúâ86400ÁßíÔºåÂ¶ÇÊûúÂΩìÂâçÊ∂àËÄóÈÄüÂ∫¶‰∏ãÂè™ËÉΩËøêË°åÂ∞ë‰∫é‰∏ÄÂ§©ÔºåÈúÄË¶ÅÊöÇÂÅú
                seconds_in_day = 86400
                if daily_runtime_seconds < seconds_in_day:
                    # ËÆ°ÁÆóÈúÄË¶ÅÊöÇÂÅúÂ§ö‰πÖÊâçËÉΩÂùáÂåÄÂàÜÈÖçÂà∞ÂÖ®Â§©
                    pause_seconds = seconds_in_day - daily_runtime_seconds
                    
                    # ÈôêÂà∂ÊöÇÂÅúÊó∂Èó¥Âú®ÂêàÁêÜËåÉÂõ¥ÂÜÖÔºà5ÁßíÂà∞30ÂàÜÈíüÔºâ
                    pause_seconds = max(5, min(1800, int(pause_seconds)))
                    
                    print_info(f"üìä Âä®ÊÄÅÊöÇÂÅúËÆ°ÁÆó:")
                    print_info(f"   Êú¨ËΩÆÊ∂àËÄó: {self.round_cu_usage:,} CU ({round_duration:.1f}Áßí)")
                    print_info(f"   ÊØèÊó•È¢ÑÁÆó: {daily_budget:,} CU")
                    print_info(f"   Ââ©‰ΩôÂ§©Êï∞: {days_remaining} Â§©")
                    print_info(f"   Âª∫ËÆÆÊöÇÂÅú: {pause_seconds} Áßí")
                    
                    return pause_seconds
        
        # ÈªòËÆ§ÊöÇÂÅúÊó∂Èó¥
        return 5
    
    async def load_private_keys_from_db(self):
        """‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÁßÅÈí•"""
        try:
            async with self.db_manager._lock:
                async with aiosqlite.connect(self.db_manager.db_path) as db:
                    cursor = await db.execute(
                        "SELECT value FROM config WHERE key = 'private_keys'"
                    )
                    result = await cursor.fetchone()
                    if result:
                        private_keys_str = result[0]
                        private_keys = private_keys_str.split(',')
                        
                        self.addresses = []
                        for private_key in private_keys:
                            try:
                                account = Account.from_key(private_key.strip())
                                self.addresses.append({
                                    'address': account.address,
                                    'private_key': private_key.strip()
                                })
                            except Exception as e:
                                logging.error(f"Âä†ËΩΩÁßÅÈí•Â§±Ë¥•: {e}")
                        
                        if self.addresses:
                            print_success(f"‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩ‰∫Ü {len(self.addresses)} ‰∏™Âú∞ÂùÄ")
                            return True
        except Exception as e:
            print_warning(f"‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÁßÅÈí•Â§±Ë¥•: {e}")
        
        return False
    
    async def show_interactive_menu(self):
        """ÊòæÁ§∫‰∫§‰∫íÂºè‰∏ªËèúÂçï"""
        while True:
            try:
                print(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
                print(f"{Fore.WHITE}{Back.BLUE} üöÄ EVMÂ§öÈìæÁõëÊéßÂ∑•ÂÖ∑ - ‰∏ªËèúÂçï {Style.RESET_ALL}")
                print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
                
                # ÊòæÁ§∫ÂΩìÂâçÁä∂ÊÄÅ
                if self.addresses:
                    print_success(f"‚úÖ Â∑≤ÈÖçÁΩÆ {len(self.addresses)} ‰∏™ÁõëÊéßÂú∞ÂùÄ")
                else:
                    print_warning("‚ö†Ô∏è  Êú™ÈÖçÁΩÆÁõëÊéßÂú∞ÂùÄ")
                
                if self.alchemy_api:
                    # ÊòæÁ§∫API‰ΩøÁî®ÁªüËÆ°
                    usage_stats = self.get_normalized_usage_stats()
                    cache_stats = self.price_checker.get_cache_stats()
                    print_info(f"üìä APIÁä∂ÊÄÅ:")
                    print_info(f"   AlchemyÊÄªËÆ°: {usage_stats.get('total_cu_rate', 0)}/1500 CU/s ({usage_stats.get('usage_percentage', 0):.1f}%)")
                    
                    # ÊòæÁ§∫ÂêÑ‰∏™APIÁöÑËØ¶ÁªÜÁä∂ÊÄÅ
                    for api_detail in usage_stats.get('api_details', []):
                        status = "üü¢" if api_detail['available'] else "üî¥"
                        print_info(f"   {status} API-{api_detail['api_index']}: {api_detail['current_cu_rate']}/500 CU/s ({api_detail['usage_percentage']:.1f}%)")
                    
                    print_info(f"   CoinGecko: {cache_stats.get('monthly_calls', 0)}/10,000 ({cache_stats.get('minute_calls', 0)}/30/min)")
                    print_info(f"   ‰ª∑Ê†ºÁºìÂ≠ò: {cache_stats.get('valid_cached', 0)} ÊúâÊïà / {cache_stats.get('total_cached', 0)} ÊÄªËÆ°")
                
                print(f"\n{Fore.YELLOW}ËØ∑ÈÄâÊã©Êìç‰Ωú:{Style.RESET_ALL}")
                print(f"{Fore.GREEN}1.{Style.RESET_ALL} üì• ÂØºÂÖ•ÁßÅÈí•")
                print(f"{Fore.GREEN}2.{Style.RESET_ALL} üöÄ ÂºÄÂßãÁõëÊéß")
                print(f"{Fore.GREEN}3.{Style.RESET_ALL} üìä Êü•ÁúãÁªüËÆ°")
                print(f"{Fore.GREEN}0.{Style.RESET_ALL} üö™ ÈÄÄÂá∫Á®ãÂ∫è")
                
                try:
                    choice = input(f"\n{Fore.CYAN}ËØ∑ËæìÂÖ•ÈÄâÊã© (0-3): {Style.RESET_ALL}").strip()
                except EOFError:
                    print_warning("Ê£ÄÊµãÂà∞EOFÔºåÈÄÄÂá∫Á®ãÂ∫è")
                    break
                
                if choice == '1':
                    await self.configure_private_keys()
                elif choice == '2':
                    if not self.addresses:
                        print_error("ËØ∑ÂÖàÂØºÂÖ•ÁßÅÈí•ÔºÅ")
                        continue
                    await self.start_monitoring()
                elif choice == '3':
                    await self.show_statistics()
                elif choice == '0':
                    print_success("ÈÄÄÂá∫Á®ãÂ∫è")
                    break
                else:
                    print_error("Êó†ÊïàÈÄâÊã©ÔºåËØ∑ËæìÂÖ• 0-3")
                    
            except KeyboardInterrupt:
                print_warning("\nÁ®ãÂ∫èË¢´‰∏≠Êñ≠ÔºåÊ≠£Âú®ÈÄÄÂá∫...")
                break
            except Exception as e:
                print_error(f"ËèúÂçïÊìç‰ΩúÂá∫Èîô: {e}")
                logging.error(f"ËèúÂçïÊìç‰ΩúÂá∫Èîô: {e}")
    
    async def show_statistics(self):
        """ÊòæÁ§∫ËØ¶ÁªÜÁªüËÆ°‰ø°ÊÅØ"""
        print(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}{Back.BLUE} üìä Á≥ªÁªüÁªüËÆ°‰ø°ÊÅØ {Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        
        # Âú∞ÂùÄÁªüËÆ°
        print(f"{Fore.YELLOW}üìç Âú∞ÂùÄÈÖçÁΩÆ:{Style.RESET_ALL}")
        print(f"   ÁõëÊéßÂú∞ÂùÄÊï∞Èáè: {len(self.addresses)}")
        if self.addresses:
            for i, addr_info in enumerate(self.addresses, 1):
                print(f"   {i}. {addr_info['address']}")
        
        # ÈìæÈÖçÁΩÆÁªüËÆ°
        if self.config.get('chains'):
            print(f"\n{Fore.YELLOW}üîó ÈìæÈÖçÁΩÆ:{Style.RESET_ALL}")
            print(f"   ÈÖçÁΩÆÈìæÊï∞Èáè: {len(self.config['chains'])}")
        
        # API‰ΩøÁî®ÁªüËÆ°
        if self.alchemy_api:
            usage_stats = self.get_normalized_usage_stats()
            print(f"\n{Fore.YELLOW}‚ö° Alchemy APIË¥üËΩΩÂùáË°°Âô®:{Style.RESET_ALL}")
            print(f"   ÊÄªÂΩìÂâçÈÄüÁéá: {usage_stats.get('total_cu_rate', 0)} CU/s (ÁõÆÊ†á: 1500)")
            print(f"   ÊÄªÊúàÂ∫¶‰ΩøÁî®: {usage_stats.get('total_monthly_usage', 0):,} / {usage_stats.get('total_monthly_limit', 0):,} CU")
            print(f"   ÊÄª‰ΩøÁî®ÁôæÂàÜÊØî: {usage_stats.get('usage_percentage', 0):.1f}%")
            
            print(f"\n{Fore.YELLOW}   APIÂÆû‰æãËØ¶ÊÉÖ:{Style.RESET_ALL}")
            for api_detail in usage_stats.get('api_details', []):
                status = "üü¢ ÂèØÁî®" if api_detail['available'] else "üî¥ ‰∏çÂèØÁî®"
                print(f"   API-{api_detail['api_index']} ({api_detail['api_key_preview']}): {api_detail['current_cu_rate']}/500 CU/s ({api_detail['usage_percentage']:.1f}%) - {status}")
        
        # CoinGeckoÁªüËÆ°
        cache_stats = self.price_checker.get_cache_stats()
        print(f"\n{Fore.YELLOW}üíé CoinGecko API:{Style.RESET_ALL}")
        print(f"   ÊúàÂ∫¶Ë∞ÉÁî®: {cache_stats.get('monthly_calls', 0)} / {cache_stats.get('monthly_limit', 10000)}")
        print(f"   ÂàÜÈíüË∞ÉÁî®: {cache_stats.get('minute_calls', 0)} / {cache_stats.get('minute_limit', 30)}")
        print(f"   ‰ª∑Ê†ºÁºìÂ≠ò: {cache_stats.get('valid_cached', 0)} ÊúâÊïà / {cache_stats.get('total_cached', 0)} ÊÄªËÆ°")
        print(f"   ÁºìÂ≠òÊó∂Èïø: 3Â§©")
        
        # ËΩ¨Ë¥¶ÁªüËÆ°
        print(f"\n{Fore.YELLOW}üí∏ ËΩ¨Ë¥¶ÁªüËÆ°:{Style.RESET_ALL}")
        print(f"   ÊÄªËΩ¨Ë¥¶Êï∞: {self.total_transfers} Á¨î")
        print(f"   ÊÄª‰ª∑ÂÄº: ${self.total_value_usd:.2f}")
        print(f"   ÁõëÊéßËΩÆÊ¨°: {self.round_count}")
        
        print(f"\n{Fore.GREEN}ÊåâÂõûËΩ¶ÈîÆËøîÂõû‰∏ªËèúÂçï...{Style.RESET_ALL}")
        try:
            input()
        except EOFError:
            pass
    
async def main():
    """‰∏ªÂáΩÊï∞"""
    print_progress("Ê≠£Âú®ÂàùÂßãÂåñEVMÂ§öÈìæÁõëÊéßÂ∑•ÂÖ∑...")
    
    app = MonitoringApp()
    
    try:
        await app.initialize()
        
        # ÊòæÁ§∫Áä∂ÊÄÅ‰ø°ÊÅØ
        print_info(f"ÊîØÊåÅ {len(ChainConfig.SUPPORTED_CHAINS)} Êù°Âå∫ÂùóÈìæ")
        if app.addresses:
            print_success(f"Â∑≤Âä†ËΩΩ {len(app.addresses)} ‰∏™ÁõëÊéßÂú∞ÂùÄ")
        else:
            print_warning("Êú™Âä†ËΩΩÁõëÊéßÂú∞ÂùÄÔºåËØ∑ÂÖàÂØºÂÖ•ÁßÅÈí•")
        
        # ËøõÂÖ•‰∫§‰∫íÂºèËèúÂçï
        await app.show_interactive_menu()
        
    except KeyboardInterrupt:
        print_warning("\nÁ®ãÂ∫èË¢´Áî®Êà∑‰∏≠Êñ≠ÔºåÊ≠£Âú®ÈÄÄÂá∫...")
    except Exception as e:
        print_error(f"Á®ãÂ∫èËøêË°åÂá∫Èîô: {e}")
        logging.error(f"Á®ãÂ∫èËøêË°åÂá∫Èîô: {e}")
        return 1
    finally:
        print_info("Á®ãÂ∫èÂ∑≤ÈÄÄÂá∫")
    
    return 0

if __name__ == "__main__":
    # ËÆæÁΩÆÂºÇÊ≠•‰∫ã‰ª∂Âæ™ÁéØÁ≠ñÁï•ÔºàWindowsÂÖºÂÆπÊÄßÔºâ
    if os.name == 'nt':
        asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
    
    exit_code = asyncio.run(main())
    exit(exit_code)
